# Converting Standard Rubik's Moves to Crawler Notation

**Author:** Claude (with Michael Ashe)
**Date:** March 1, 2026
**Status:** Research / Pre-implementation

---

## 1. Introduction

### The Problem

In Cube Crawler mode, a Rubik's cube sits on a checkerboard grid and can only move using a restricted set of physical operations: rolling (which always spins two opposing faces simultaneously), spinning the top layer, or spinning the top two layers (lazy susan). The cube cannot perform a standard Rubik's move like "R" (rotate just the right face) — every crawl move pairs two opposite faces.

The challenge: given a scrambled cube on the crawler board, solve it using only crawler-legal moves.

This is analogous to the **Knight's Tour** problem — constrained movement on a grid where the allowed operations are severely limited compared to free movement. Like the knight's L-shaped jump, the crawler's paired-face rolls are powerful but awkward, and the grid boundaries add further constraints.

### Why This Is Hard

A standard Rubik's solver (Kociemba algorithm) finds solutions averaging ~20 moves using 6 independent face rotations (U, D, R, L, F, B). The crawler has only 4 types of cube-state-changing operations, and **none of them correspond to a single face rotation**. Converting between these two "languages" is the central challenge.

---

## 2. Formal Definitions

### 2.1 Standard Rubik's Moves

The 6 face rotations: **U** (up), **D** (down), **F** (front), **B** (back), **R** (right), **L** (left). Each can be clockwise (R) or counterclockwise (R'). These are the building blocks of all Rubik's solutions.

### 2.2 Crawler Moves

The crawler has **8 moves** in 4 pairs:

| Crawler Move | Cube State Effect | Board Effect |
|---|---|---|
| `+x` (crawl right) | F + B' (F clockwise, B counterclockwise) | Move +1 in X |
| `-x` (crawl left) | F' + B | Move -1 in X |
| `+z` (crawl forward) | R' + L | Move +1 in Z |
| `-z` (crawl backward) | R + L' | Move -1 in Z |
| `spin1` | U (top layer clockwise) | Stay in place |
| `spin1'` | U' (top layer counterclockwise) | Stay in place |
| `spin2` | U + E' (top 2 layers clockwise) | Stay in place, heading changes |
| `spin2'` | U' + E (top 2 layers counterclockwise) | Stay in place, heading changes |

**Key notation:**
- E' = equator (middle horizontal layer) clockwise from above
- spin2 is also called "wide u" in standard notation — it's like a lazy susan
- Crawl moves always rotate **two opposing faces in opposite directions**
- The cube's face labels (U/D/F/B/R/L) are fixed to the cube, not the board

### 2.3 Board Constraints

The cube sits on an N×N grid (3×3, 5×5, or 8×8). Crawl moves that would take the cube off the grid are illegal. Spin moves are always legal (the cube doesn't move). The cube's heading (which world-direction F faces) changes with spin2 moves, which affects which direction crawl moves go on the board.

### 2.4 The Cube State Generators

Ignoring board position, the crawler's effect on cube state is generated by 4 operations:

```
G = ⟨ U,  E',  F·B',  R·L' ⟩
```

Where:
- **U** = spin1 (directly available)
- **E'** = spin1' · spin2 (derived: U' then U·E' = E')
- **F·B'** = crawl +x (directly available)
- **R·L'** = crawl -z (directly available)

All other crawler moves are inverses or combinations of these four.

---

## 3. The Central Question: Can Crawler Moves Solve Any Cube?

### 3.1 What We Need to Prove

For the crawler solver to work, we need one of:

**(A)** The crawler generators produce the **full Rubik's cube group** — meaning any standard face move (R, D, F, etc.) can be expressed as some sequence of crawler moves. Then we can convert any Kociemba solution.

**(B)** The crawler generators produce a **subgroup** that is large enough — specifically, any cube state reachable by crawler scrambling can be solved by crawler moves. (This is trivially true by reversing the scramble, but we want SHORT solutions.)

### 3.2 The Center Problem

**Critical observation:** spin2 moves center stickers. After spin2 CW, the centers of F, R, B, L rotate among each other. In the standard Rubik's cube model, centers are **fixed** (they define the faces). This means:

- The standard Rubik's group operates in a **fixed-center** model
- The crawler group operates in a **movable-center** model (because spin2 moves centers)
- These are **different mathematical objects**

This is why our facelet-string approach failed: after spin2 moves, the CrawlerCube's centers are displaced, producing facelet strings that the fixed-center Kociemba solver considers "impossible."

### 3.3 Separating the Problem

We can decompose the crawler group into:

1. **Standard-group component:** {U, F·B', R·L'} — these don't move centers and ARE in the standard Rubik's group
2. **Center-rotating component:** {E'} (derived from spin2) — this moves centers and is NOT in the standard group

The standard-group component ⟨U, F·B', R·L'⟩ is what we need to analyze for solving capability. If this subgroup equals the full standard Rubik's group, we can solve any cube without spin2. If not, we need spin2 but must handle the center displacement.

### 3.4 Evidence That ⟨U, F·B', R·L'⟩ Generates the Full Group

**Commutator analysis:** The commutator [F·B', U] = (F·B')·U·(F'·B)·U' produces:

- Corner permutation: **(URF UFL UBL)(UBR DRF DBR)** — two 3-cycles
- Edge permutation: **(UF RF UR)(UB RB UL)** — two 3-cycles

This is significant because:

1. **3-cycles generate the alternating group** (all even permutations)
2. Combined with U (which provides odd permutations), we can reach **any** permutation with matching corner/edge parity
3. The 3-cycles move pieces between the **U layer and D layer** (e.g., UBR→DRF), proving we can access bottom-layer pieces

**What this means:** Through sequences of crawl moves and spin1, we can likely move any corner or edge piece to any position. This strongly suggests the subgroup is the full standard Rubik's group.

**What remains to prove:** We need to verify that we can also achieve any **orientation** of corners and edges (not just position). This requires computing additional commutators — a task well-suited to computer verification.

### 3.5 The D Face Problem

The D (bottom) face deserves special attention:

- **No crawler move directly rotates D.** U rotates U, E' rotates the equator, F·B' rotates F and B, R·L' rotates R and L. The D face grid is never directly spun.
- **D-adjacent stickers ARE affected** by F, B, R, L moves (through edge/corner cycling). So D's pieces can be manipulated indirectly.
- **The D face rotation permutation** (DRF→DBR→DBL→DLF cycle) must be constructed from commutators and products of our generators.

This is analogous to the Knight's Tour constraint: the knight can never move just 1 square, but through sequences of L-shaped jumps, it can reach any square.

**Conjecture:** The D face rotation can be expressed as a sequence of ~10-20 crawler moves (to be verified by computer search).

---

## 4. Practical Approaches

### 4.1 Approach A: Macro Substitution (Recommended First Implementation)

**Idea:** Pre-compute a crawler sequence for each standard face move. Then convert any Kociemba solution by substituting each move with its crawler equivalent.

**Steps:**
1. Use **BFS (breadth-first search)** from the identity state, applying crawler moves level by level
2. At each level, check if the current state matches any standard face move (R, R', L, L', F, F', B, B', D, D')
3. Record the shortest crawler sequence for each
4. U and U' are trivial (= spin1, spin1')

**Feasibility:** With branching factor 8 and expected depth ~8-12 moves, the search space is 8^12 ≈ 69 billion states at worst. However:
- We can prune inverse moves (don't do +x immediately after -x)
- We can use symmetry (R sequence = mirror of L sequence)
- We only need to search until we find all 10 targets (R, R', L, L', F, F', B, B', D, D')
- We can search from BOTH ends (meet-in-the-middle): generate states forward from identity AND backward from each target

**Expected result:** Each standard face move expressible in ~8-16 crawler moves.

**Total solution length:** Kociemba ~20 moves × ~12 crawler moves each = ~240 crawler moves. Long, but computable and correct.

### 4.2 Approach B: Commutator Library

Instead of macro-substituting whole face moves, build a library of useful commutators:

| Sequence | Effect | Length |
|---|---|---|
| (F·B')·U·(F'·B)·U' | 3-cycle of corners + 3-cycle of edges | 4 moves |
| U·(R·L')·U'·(R'·L) | Different 3-cycle | 4 moves |
| [(F·B'), (R·L')] | Another permutation | 4 moves |
| Conjugates of above | Shifted versions | 6-8 moves |

Then solve the cube piece-by-piece using these building blocks, similar to the beginner's method:

1. **Phase 1:** Solve U-layer corners using commutators
2. **Phase 2:** Solve U-layer edges
3. **Phase 3:** Solve middle-layer edges
4. **Phase 4:** Solve D-layer (using longer commutator sequences)

**Advantage:** More natural for the crawler — looks like deliberate solving, not random face rotations.
**Disadvantage:** Longer solutions, harder to implement.

### 4.3 Approach C: Direct IDA* Solver

Build a solver that searches directly in the crawler move space:

- **State:** 54-sticker cube state (ignoring board position for now)
- **Moves:** 8 crawler moves
- **Goal:** All faces uniform color
- **Heuristic:** Pattern database or Manhattan distance of pieces
- **Algorithm:** IDA* (iterative deepening A*)

**Advantage:** Finds optimal or near-optimal crawler solutions directly.
**Disadvantage:** Requires building custom pruning tables. Much slower than Kociemba. May need significant computation time per solve.

**Feasibility:** God's number for standard Rubik's is 20 (with 18 moves per turn). For crawler with 8 moves per turn, God's number is likely higher (~30-50?). IDA* with a good heuristic should handle this in reasonable time on modern hardware.

### 4.4 Approach D: Hybrid (Recommended Long-Term)

Combine Kociemba with crawler-aware execution:

1. **Fix the frame mapping** (the v1.0.11 bug): Get Kociemba solutions working with solveFaceRotate (single face rotations, cube stays in place)
2. **Replace solveFaceRotate with crawler macros:** Each face rotation gets converted to a short crawler sequence
3. **Add board awareness:** Track position during solve, use spin2 to reorient if a crawl would go off-board
4. **Optimize:** Look for cancellations between consecutive macros

This gives us a working solver quickly (step 1), then progressively improves it (steps 2-4).

---

## 5. Board Constraint Integration

### 5.1 Position Tracking During Solve

During crawler solving, the cube moves on the board. We must track:
- **(gridX, gridZ):** Current position on the board
- **heading:** Which world-direction the cube's F face points (changes with spin2)

Each crawl move changes position based on the current heading:
- If heading = North: +x moves East, +z moves North, etc.
- If heading = East: +x moves North, +z moves West, etc.

### 5.2 Boundary Avoidance

On a 3×3 grid, the cube starts at center (1,1) with only 1 step of room in each direction. A macro that requires 3 consecutive crawls in the same direction is impossible from the center.

**Strategies:**
1. **Pre-check:** Before executing a macro, verify all crawl moves in it are legal from the current position
2. **Reorient:** Use spin2 to change heading so the macro's crawls go in a legal direction
3. **Relocate:** Use crawl moves (which also affect cube state!) to move to a position with more room, then compensate for the state changes
4. **Grid-size-dependent macros:** Different (possibly longer) macros for small vs. large grids

### 5.3 Grid Size Implications

| Grid | Max consecutive crawls in one direction | Solving difficulty |
|---|---|---|
| 3×3 | 2 (from center) | Very constrained — may need special short macros |
| 5×5 | 4 (from center) | Moderate — most macros should fit |
| 8×8 | 7 (from center) | Comfortable — almost unconstrained |

**Recommendation:** Develop macros for the 3×3 case first (hardest constraint). Larger grids will work automatically.

### 5.4 The "Return Home" Problem

After solving, the cube may be at a different board position than where it started. Options:
1. Don't care — solved is solved regardless of position
2. Navigate back — but crawl moves change cube state, so we'd need to crawl back without un-solving
3. Use spin2 to change heading, then crawl back using moves that cancel each other's cube effects (e.g., +x then -x returns the cube but does F·B'·F'·B = identity on the cube). Two crawl moves in opposite directions = return to original position with no net cube state change.

Option 3 is clean: after solving, crawl home using paired forward/backward moves.

---

## 6. The Spin2/Center Problem: Resolution

### 6.1 The Bug We Found

The CrawlerCube tracks center positions correctly (spin2 moves centers). But Kociemba assumes fixed centers. This mismatch caused:
- **Facelet approach (v1.0.12):** Invalid facelet string → solver timeout
- **Move-string approach (v1.0.11):** Valid move string → correct solution, but executed in wrong reference frame

### 6.2 The Quick Fix (For Move-String Approach)

The v1.0.11 approach was 90% correct. The fix:

1. `crawlerHistoryToMoveString()` generates a move string AND tracks the accumulated frame rotation from spin2 moves
2. Kociemba solves the move string → solution in Kociemba's (rotated) frame
3. **NEW: Apply inverse frame mapping** to convert solution face names back to physical face names
4. Execute with solveFaceRotate using the physical face names

**Example:** If after spin2 moves the frame says physical-F = Kociemba-L, and Kociemba's solution says "L", execute `solveFaceRotate('F', ...)`.

This gets us a WORKING solver immediately (cube does face rotations in place).

### 6.3 The Full Fix (For Crawler-Move Solving)

For full crawler solving (where the cube physically crawls to solve):

1. **Don't use spin2 during solving** — use only {U, U', F·B', F'·B, R'·L, R·L'} which don't move centers
2. Use spin2 only for scrambling and manual play
3. This keeps us in the standard Rubik's group where Kociemba solutions are valid

OR:

1. Solve in the crawler group directly (Approach C from Section 4)
2. Accept that "solved" means all faces uniform (may be rotated relative to original)
3. This sidesteps the center problem entirely

---

## 7. Implementation Roadmap

### Phase 1: Quick Win — Fix the Frame Mapping (Days)

- Restore `crawlerHistoryToMoveString()` with frame tracking
- Add inverse frame mapping to solution execution
- Cube solves using solveFaceRotate (in-place face rotations)
- **Result:** Working solver, cube animates face turns on the board

### Phase 2: Compute Crawler Macros (Days to Weeks)

- Write a BFS program to find shortest crawler sequences for R, L, F, B, D (and their inverses)
- Build a macro lookup table
- **Result:** We know exactly how to express each face move as crawler moves

### Phase 3: Crawler-Native Solving (Weeks)

- Replace solveFaceRotate with macro execution
- Add board position tracking during solve
- Add boundary checking and spin2 reorientation when needed
- **Result:** Cube physically crawls around the board while solving

### Phase 4: Optimization (Ongoing)

- Optimize macros for shorter sequences
- Add cancellation detection between consecutive macros
- Consider IDA* for direct crawler solutions (shorter overall)
- Board-aware solving (prefer macros that keep cube near center)

---

## 8. Open Questions

1. **Exact macro lengths:** What are the shortest crawler sequences for R, L, F, B, D? (Requires BFS computation)

2. **Does ⟨U, F·B', R·L'⟩ = full Rubik's group?** Strong evidence says yes, but a rigorous proof (or computer verification) is needed.

3. **God's number for crawler moves:** What's the maximum number of crawler moves needed to solve any cube? (Likely 30-60, vs. 20 for standard moves)

4. **3×3 grid feasibility:** Can every scrambled state be solved on a 3×3 grid, or are some states unsolvable due to boundary constraints? (The cube can always spin in place, so likely yes, but macros may need to be specially designed)

5. **Optimal solve length:** With macro substitution, solutions will be ~200-300 crawler moves. Can direct IDA* or hybrid methods find solutions under 100 moves?

6. **Visual appeal:** Long crawler solutions may look random/chaotic. Can we bias toward solutions that "look" more deliberate? (Layer-by-layer approach helps here)

---

## 9. Summary

The crawler solving problem has three layers:

| Layer | Problem | Status |
|---|---|---|
| **Cube solving** | Generate a solution from any state | SOLVED (Kociemba) |
| **Move translation** | Convert standard moves to crawler moves | THEORETICALLY POSSIBLE, needs computation |
| **Board navigation** | Execute crawler moves within grid bounds | SOLVABLE with position tracking + reorientation |

The **immediate next step** is Phase 1 (fix the frame mapping) to get a working solver using face rotations. Then Phase 2 (BFS for macros) to enable true crawler solving.

The hardest open problem is finding efficient crawler macros, particularly for the **D face** which is never directly rotated by any crawler move. This is the Knight's Tour equivalent — the most constrained piece of the puzzle.

---

## Appendix A: Commutator Proof Sketch

The commutator [F·B', U] = (F·B')·U·(F'·B)·U' produces:

**Corners:** (URF → UFL → UBL → URF)(UBR → DRF → DBR → UBR)

This is two 3-cycles. Notably, pieces move between U-layer and D-layer (UBR↔DRF, specifically). This proves D-layer pieces are accessible.

By conjugating this commutator with other crawler moves, we can produce 3-cycles involving any three corners. Since 3-cycles generate all even permutations, and U provides the odd component, we can reach any corner permutation.

**Edges:** (UF → RF → UR → UF)(UB → RB → UL → UB)

Similarly, two 3-cycles of edges. Same argument applies: all edge permutations are reachable.

## Appendix B: Notation Reference

| Symbol | Meaning |
|---|---|
| F, B, R, L, U, D | Standard face rotations (clockwise) |
| F', B', etc. | Counterclockwise rotations |
| E | Equator slice (follows D direction) |
| E' | Equator slice (opposite D = same as U from above) |
| F·B' | Simultaneous F clockwise + B counterclockwise |
| [A, B] | Commutator = A·B·A⁻¹·B⁻¹ |
| y | Whole-cube rotation CW from above |
| u | Wide U move (= U + E' = top 2 layers) |
| ⟨...⟩ | Group generated by the enclosed elements |
