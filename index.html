<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rubik's Cube Solver</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #1a1a2e;
  color: #e0e0e0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}

#canvas-container {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
}

canvas {
  display: block;
}

/* Top bar */
#top-bar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  background: rgba(26, 26, 46, 0.85);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  z-index: 100;
}

#top-bar .logo {
  font-size: 16px;
  font-weight: 700;
  letter-spacing: 1px;
}

/* Bottom controls */
#bottom-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 12px 16px;
  background: rgba(26, 26, 46, 0.85);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  z-index: 100;
}

#move-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-bottom: 8px;
}

#action-buttons {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
}

.btn {
  background: rgba(255, 255, 255, 0.08);
  color: #e0e0e0;
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 8px;
  padding: 8px 16px;
  font-size: 13px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
}

.btn:hover {
  background: rgba(255, 255, 255, 0.15);
  border-color: rgba(255, 255, 255, 0.25);
}

.btn:active {
  transform: scale(0.96);
}

.btn-primary {
  background: rgba(99, 102, 241, 0.3);
  border-color: rgba(99, 102, 241, 0.5);
}

.btn-primary:hover {
  background: rgba(99, 102, 241, 0.45);
}

/* Face control buttons */
#face-controls {
  display: none;
  justify-content: center;
  gap: 4px;
  flex-wrap: wrap;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid rgba(255, 255, 255, 0.08);
}

#face-controls.visible {
  display: flex;
}

.speed-select {
  appearance: none;
  -webkit-appearance: none;
  background: rgba(255, 255, 255, 0.08) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23888'/%3E%3C/svg%3E") no-repeat right 10px center;
  padding-right: 28px;
  color: #e0e0e0;
  font-size: 13px;
}

.speed-select option {
  background: #1a1a2e;
  color: #e0e0e0;
}

.face-btn {
  background: rgba(255, 255, 255, 0.06);
  color: #e0e0e0;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  padding: 6px 10px;
  font-size: 12px;
  font-family: 'Courier New', monospace;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s ease;
  min-width: 36px;
  text-align: center;
}

.face-btn:hover {
  background: rgba(255, 255, 255, 0.14);
}

.face-btn:active {
  transform: scale(0.94);
}

/* Status / info overlay */
#info-overlay {
  position: fixed;
  top: 56px;
  right: 12px;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.4);
  z-index: 100;
  text-align: right;
  line-height: 1.6;
}

/* Loading screen */
#loading {
  position: fixed;
  inset: 0;
  background: #1a1a2e;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  transition: opacity 0.5s ease;
}

#loading.hidden {
  opacity: 0;
  pointer-events: none;
}

#loading .spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255, 255, 255, 0.1);
  border-top-color: #6366f1;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

#loading p {
  margin-top: 16px;
  font-size: 14px;
  color: rgba(255, 255, 255, 0.5);
}

/* Solver status overlay */
#solver-status {
  position: fixed;
  top: 56px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(26, 26, 46, 0.9);
  border: 1px solid rgba(99, 102, 241, 0.4);
  border-radius: 8px;
  padding: 8px 20px;
  font-size: 14px;
  color: #e0e0e0;
  z-index: 200;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

/* Solution playback bar */
#solution-bar {
  display: none;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 8px;
  padding: 8px 12px;
  background: rgba(99, 102, 241, 0.08);
  border: 1px solid rgba(99, 102, 241, 0.2);
  border-radius: 8px;
}

#solution-tokens {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  justify-content: center;
  max-height: 48px;
  overflow-y: auto;
}

.sol-token {
  font-family: 'Courier New', monospace;
  font-size: 13px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  color: rgba(255, 255, 255, 0.5);
  background: rgba(255, 255, 255, 0.04);
}

.sol-token.sol-current {
  color: #fff;
  background: rgba(99, 102, 241, 0.5);
}

.sol-token.sol-done {
  color: rgba(255, 255, 255, 0.25);
}

#solution-controls {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

#solution-progress {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.5);
  min-width: 50px;
  text-align: center;
}

.sol-btn {
  padding: 6px 12px;
  font-size: 14px;
  min-width: unset;
}

/* Show Off mode bar */
#showoff-bar {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 12px 16px;
  background: rgba(26, 26, 46, 0.9);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  z-index: 100;
  flex-direction: column;
  gap: 10px;
  align-items: center;
}

#showoff-bar.visible {
  display: flex;
}

#showoff-grid-btns {
  display: flex;
  gap: 6px;
  align-items: center;
}

.grid-btn {
  background: rgba(255, 255, 255, 0.08);
  color: #e0e0e0;
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 8px;
  padding: 6px 12px;
  font-size: 13px;
  font-family: inherit;
  cursor: pointer;
  transition: all 0.2s ease;
}

.grid-btn:hover {
  background: rgba(255, 255, 255, 0.15);
}

.grid-btn.active {
  background: rgba(99, 102, 241, 0.3);
  border-color: rgba(99, 102, 241, 0.5);
}

#showoff-actions {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
  justify-content: center;
}

#showoff-actions label {
  font-size: 13px;
  color: rgba(255, 255, 255, 0.7);
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
}

/* Crawler mode bar */
#crawler-bar {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 12px 16px;
  background: rgba(26, 26, 46, 0.9);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-top: 1px solid rgba(255, 255, 255, 0.08);
  z-index: 100;
  flex-direction: column;
  gap: 8px;
  align-items: center;
}
#crawler-bar.visible { display: flex; }
#crawler-actions {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
  justify-content: center;
}
#crawler-info {
  display: flex;
  gap: 16px;
  align-items: center;
  justify-content: center;
}

/* Debug log panel — hidden by default, toggled via Log button */
#debug-log {
  display: none;
  flex-direction: column;
  position: fixed;
  top: 52px;
  left: 8px;
  width: 320px;
  z-index: 300;
}
#debug-log.visible {
  display: flex;
}

#debug-log-header {
  display: flex;
  justify-content: space-between;
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid rgba(99, 102, 241, 0.4);
  border-bottom: none;
  border-radius: 8px 8px 0 0;
  padding: 4px 8px;
}

#debug-log-header span { color: #0f0; font-size: 11px; }

#debug-log-header button {
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  color: #fff;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 4px;
  cursor: pointer;
}

#debug-log-content {
  width: 100%;
  height: 35vh;
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid rgba(99, 102, 241, 0.4);
  border-top: none;
  border-radius: 0 0 8px 8px;
  padding: 4px 8px;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  line-height: 1.4;
  color: #0f0;
  resize: none;
  outline: none;
}
</style>
</head>
<body>

<div id="loading">
  <div class="spinner"></div>
  <p>Loading cube...</p>
</div>

<div id="top-bar">
  <div class="logo">RUBIK'S SOLVER <span style="font-size:10px;opacity:0.5;font-weight:400">v1.0.9</span></div>
  <div style="display:flex;gap:8px;">
    <button class="btn" id="btn-toggle-face-controls" title="Toggle face buttons">Controls</button>
    <button class="btn btn-primary" id="btn-showoff" title="Show Off mode">Show Off</button>
    <button class="btn btn-primary" id="btn-crawler" title="Cube Crawler">Crawler</button>
    <button class="btn" id="btn-debug-toggle" title="Toggle debug log">Log</button>
    <button class="btn" id="btn-help" title="Keyboard shortcuts">?</button>
  </div>
</div>

<div id="canvas-container"></div>

<div id="debug-log">
  <div id="debug-log-header">
    <span>Debug Log</span>
    <div>
      <button id="debug-copy">Copy</button>
      <button id="debug-clear">Clear</button>
    </div>
  </div>
  <textarea id="debug-log-content" readonly></textarea>
</div>

<div id="info-overlay">
  <div id="move-count">Moves: 0</div>
</div>

<div id="solver-status" style="display:none;"></div>

<div id="bottom-bar">
  <div id="move-controls">
    <button class="btn" id="btn-undo" title="Undo last move">↩ Undo</button>
    <button class="btn" id="btn-redo" title="Redo">Redo ↪</button>
    <button class="btn" id="btn-reset" title="Reset to solved">Reset</button>
  </div>
  <div id="action-buttons">
    <button class="btn btn-primary" id="btn-scramble">Scramble</button>
    <select class="btn speed-select" id="speed-select" title="Animation speed">
      <option value="400">Slow</option>
      <option value="200" selected>Medium</option>
      <option value="80">Fast</option>
      <option value="1">Instant</option>
    </select>
    <button class="btn btn-primary" id="btn-solve">Solve</button>
    <button class="btn" id="btn-flip" title="Flip cube upside-down (x2)">Flip</button>
  </div>
  <div id="solution-bar" style="display:none;">
    <div id="solution-tokens"></div>
    <div id="solution-controls">
      <button class="btn sol-btn" id="sol-prev" title="Step back">◀</button>
      <button class="btn sol-btn btn-primary" id="sol-play" title="Play/Pause">▶</button>
      <button class="btn sol-btn" id="sol-next" title="Step forward">▶</button>
      <span id="solution-progress">0 / 0</span>
      <button class="btn sol-btn" id="sol-dismiss" title="Dismiss solution">✕</button>
    </div>
  </div>
  <div id="face-controls">
    <!-- Filled by JS -->
  </div>
</div>

<div id="showoff-bar">
  <div id="showoff-grid-btns">
    <span style="font-size:12px;color:rgba(255,255,255,0.5);margin-right:4px;">Grid:</span>
    <button class="grid-btn" data-grid="1">1</button>
    <button class="grid-btn" data-grid="2">2&times;2</button>
    <button class="grid-btn active" data-grid="3">3&times;3</button>
    <button class="grid-btn" data-grid="4">4&times;4</button>
    <button class="grid-btn" data-grid="5">5&times;5</button>
  </div>
  <div id="showoff-actions">
    <button class="btn btn-primary" id="so-scramble">Scramble All</button>
    <select class="btn speed-select" id="so-speed">
      <option value="400">Slow</option>
      <option value="200">Medium</option>
      <option value="80" selected>Fast</option>
      <option value="1">Instant</option>
    </select>
    <button class="btn btn-primary" id="so-solve">Solve All</button>
    <label><input type="checkbox" id="so-continuous"> Continuous</label>
    <button class="btn" id="so-exit">Exit</button>
  </div>
</div>

<div id="crawler-bar">
  <div id="crawler-actions">
    <button class="grid-btn" data-crawl-grid="3">3&times;3</button>
    <button class="grid-btn" data-crawl-grid="5">5&times;5</button>
    <button class="grid-btn active" data-crawl-grid="8">8&times;8</button>
    <span style="width:8px"></span>
    <button class="btn btn-primary" id="cr-demo">Demo</button>
    <button class="btn btn-primary" id="cr-scramble">Scramble</button>
    <button class="btn btn-primary" id="cr-solve" disabled>Solve</button>
    <select class="btn" id="cr-speed">
      <option value="600">Slow</option>
      <option value="350" selected>Medium</option>
      <option value="150">Fast</option>
      <option value="step">Step</option>
    </select>
    <button class="btn" id="cr-step-back" style="display:none" title="Step back">&laquo;</button>
    <button class="btn" id="cr-step-fwd" style="display:none" title="Step forward">&raquo;</button>
    <button class="btn" id="cr-reset">Reset</button>
    <button class="btn" id="cr-exit">Exit</button>
  </div>
  <div id="crawler-info" style="display:flex;gap:16px;align-items:center">
    <span id="crawler-move-count" style="font-size:12px;color:rgba(255,255,255,0.7)">Moves: 0</span>
    <span id="crawler-status" style="font-size:12px;color:rgba(255,255,255,0.5)">Arrow keys to steer · Space=spin2 · Tab=spin1</span>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
    "cubejs": "https://cdn.jsdelivr.net/npm/cubejs@1.3.2/+esm"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
import Cube from 'cubejs';

// ─── DEBUG LOG ───────────────────────────────────────────────

const debugLogEl = document.getElementById('debug-log-content');
const debugLogPanel = document.getElementById('debug-log');
let debugLines = [];

function debugLog(msg) {
  const ts = ((performance.now() / 1000) | 0) + '.' +
    String(Math.round(performance.now()) % 1000).padStart(3, '0');
  const line = `[${ts}] ${msg}`;
  debugLines.push(line);
  if (debugLines.length > 200) debugLines.shift();
  const text = debugLines.join('\n');
  debugLogEl.value = text;
  debugLogEl.scrollTop = debugLogEl.scrollHeight;
  // Persist to localStorage so log survives a crash
  try { localStorage.setItem('rubiks_debug_log', text); } catch(e) {}
  console.log('[SO]', msg);
}

// On load, recover previous crash log if any
try {
  const prev = localStorage.getItem('rubiks_debug_log');
  if (prev) {
    debugLines = prev.split('\n');
    debugLogEl.value = '--- RECOVERED FROM PREVIOUS SESSION ---\n' + prev + '\n--- NEW SESSION ---\n';
  }
} catch(e) {}

document.getElementById('debug-copy').addEventListener('click', () => {
  debugLogEl.select();
  document.execCommand('copy');
  debugLog('(copied)');
});
document.getElementById('debug-clear').addEventListener('click', () => {
  debugLines = [];
  debugLogEl.value = '';
  try { localStorage.removeItem('rubiks_debug_log'); } catch(e) {}
});
document.getElementById('btn-debug-toggle').addEventListener('click', () => {
  debugLogPanel.classList.toggle('visible');
});

debugLog('Rubiks Solver v1.0.9 starting');

// ─── CONSTANTS ───────────────────────────────────────────────

const CUBIE_SIZE = 1;
const GAP = 0.06;
const STEP = CUBIE_SIZE + GAP;
const CORNER_RADIUS = 0.12;
const CORNER_SEGMENTS = 4;

// Standard Rubik's colors: R, L, U, D, F, B  (+X, -X, +Y, -Y, +Z, -Z)
const FACE_COLORS = {
  R: 0xc41e3a,  // red    +X
  L: 0xff5800,  // orange -X
  U: 0xffffff,  // white  +Y
  D: 0xffd500,  // yellow -Y
  F: 0x009b48,  // green  +Z
  B: 0x0045ad,  // blue   -Z
};
const INTERIOR_COLOR = 0x1a1a1a;

// Face name → axis & direction mapping
const FACES = {
  R: { axis: 'x', layer:  1, dir:  1 },
  L: { axis: 'x', layer: -1, dir: -1 },
  U: { axis: 'y', layer:  1, dir:  1 },
  D: { axis: 'y', layer: -1, dir: -1 },
  F: { axis: 'z', layer:  1, dir:  1 },
  B: { axis: 'z', layer: -1, dir: -1 },
};

// ─── DYNAMIC FACE MAPPING ────────────────────────────────────
// Maps relative directions (Front, Right, Up, etc.) to physical faces
// based on where the camera is looking. This makes F/R/L/U/D/B keyboard
// controls work like holding a real cube — "Front" is whatever face
// you're looking at.

const FACE_NORMALS = {
  R: new THREE.Vector3( 1,  0,  0),
  L: new THREE.Vector3(-1,  0,  0),
  U: new THREE.Vector3( 0,  1,  0),
  D: new THREE.Vector3( 0, -1,  0),
  F: new THREE.Vector3( 0,  0,  1),
  B: new THREE.Vector3( 0,  0, -1),
};

function getViewFaces() {
  camera.updateMatrixWorld();

  // "Front" = the face whose outward normal points toward the camera.
  // That's the face you're looking at. Use camera position (from origin
  // toward camera) — NOT negated.
  const camToward = camera.position.clone().normalize();

  // Camera's actual right and up vectors from its world matrix.
  // (camera.up is always (0,1,0) with OrbitControls — that's not
  // the real screen-up when the camera is tilted.)
  const camRight = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
  const camUp    = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 1);

  function bestFace(dir) {
    let best = null, bestDot = -2;
    for (const [name, normal] of Object.entries(FACE_NORMALS)) {
      const d = dir.dot(normal);
      if (d > bestDot) { bestDot = d; best = name; }
    }
    return best;
  }

  const front = bestFace(camToward);    // face pointing at us = front
  const up    = bestFace(camUp);        // face in screen-up direction
  const right = bestFace(camRight);     // face in screen-right direction

  const OPP = { R: 'L', L: 'R', U: 'D', D: 'U', F: 'B', B: 'F' };

  return {
    F: front,
    B: OPP[front],
    U: up,
    D: OPP[up],
    R: right,
    L: OPP[right],
  };
}

// ─── THREE.JS SETUP ──────────────────────────────────────────

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(6, 5, 6);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Orbit camera controls
const orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.enableDamping = true;
orbitControls.dampingFactor = 0.08;
orbitControls.enablePan = false;
orbitControls.minDistance = 4;
orbitControls.maxDistance = 15;

// ─── LIGHTING ────────────────────────────────────────────────

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
directionalLight.position.set(5, 8, 5);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.set(1024, 1024);
scene.add(directionalLight);

const fillLight = new THREE.DirectionalLight(0xb0c4ff, 0.3);
fillLight.position.set(-4, 2, -3);
scene.add(fillLight);

// Subtle glow background
const bgGradient = new THREE.Color(0x16213e);
scene.background = bgGradient;
scene.fog = new THREE.FogExp2(0x16213e, 0.02);

// ─── CUBE STATE ──────────────────────────────────────────────

/*
  cubeState[face] = 2D array [row][col] of color codes.
  face: 'U','D','F','B','L','R'
  color codes: 'W','Y','G','B','R','O'

  Looking at each face head-on:
    [0][0] [0][1] [0][2]
    [1][0] [1][1] [1][2]
    [2][0] [2][1] [2][2]
*/
const COLOR_CODE_MAP = {
  U: 'W', D: 'Y', F: 'G', B: 'B', R: 'R', L: 'O'
};

const cubeState = {};

function initCubeState() {
  for (const [face, code] of Object.entries(COLOR_CODE_MAP)) {
    cubeState[face] = Array.from({ length: 3 }, () => Array(3).fill(code));
  }
}

initCubeState();

// ─── SOLVER STATE ────────────────────────────────────────────

let solverReady = false;
let currentSolution = null;  // { moves: [{face,clockwise}], index: 0 }
let solutionPlaying = false;

// ─── BUILD CUBIES ────────────────────────────────────────────

const cubieGroup = new THREE.Group();
scene.add(cubieGroup);

// Each cubie is a mesh with per-face materials
const cubies = []; // { mesh, x, y, z } where x,y,z ∈ {-1,0,1}

function faceColor(x, y, z, faceIndex) {
  // faceIndex: 0=+X(R), 1=-X(L), 2=+Y(U), 3=-Y(D), 4=+Z(F), 5=-Z(B)
  if (faceIndex === 0 && x ===  1) return FACE_COLORS.R;
  if (faceIndex === 1 && x === -1) return FACE_COLORS.L;
  if (faceIndex === 2 && y ===  1) return FACE_COLORS.U;
  if (faceIndex === 3 && y === -1) return FACE_COLORS.D;
  if (faceIndex === 4 && z ===  1) return FACE_COLORS.F;
  if (faceIndex === 5 && z === -1) return FACE_COLORS.B;
  return INTERIOR_COLOR;
}

function createCubie(x, y, z) {
  const geo = new RoundedBoxGeometry(CUBIE_SIZE, CUBIE_SIZE, CUBIE_SIZE, CORNER_SEGMENTS, CORNER_RADIUS);

  // 6 materials, one per face: +X, -X, +Y, -Y, +Z, -Z
  const materials = [];
  for (let i = 0; i < 6; i++) {
    const color = faceColor(x, y, z, i);
    materials.push(new THREE.MeshStandardMaterial({
      color,
      roughness: color === INTERIOR_COLOR ? 0.9 : 0.35,
      metalness: color === INTERIOR_COLOR ? 0.0 : 0.05,
    }));
  }

  const mesh = new THREE.Mesh(geo, materials);
  mesh.position.set(x * STEP, y * STEP, z * STEP);
  mesh.castShadow = true;
  mesh.receiveShadow = true;

  // Store logical position
  mesh.userData.pos = { x, y, z };
  cubieGroup.add(mesh);
  cubies.push(mesh);
  return mesh;
}

function buildCube() {
  // Clear existing
  while (cubieGroup.children.length) {
    const child = cubieGroup.children[0];
    cubieGroup.remove(child);
    child.geometry.dispose();
    child.material.forEach(m => m.dispose());
  }
  cubies.length = 0;

  for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
      for (let z = -1; z <= 1; z++) {
        createCubie(x, y, z);
      }
    }
  }
}

buildCube();

// ─── FACE LABELS (dynamic F/R/L/U/D/B on center cubies) ─────

const faceLabelGroup = new THREE.Group();
scene.add(faceLabelGroup);
const faceLabels = {}; // physicalFace -> { mesh, canvas, ctx, texture }

// How far from origin each label plane sits (just outside the cubie face)
const LABEL_OFFSET = STEP + CUBIE_SIZE / 2 + 0.02;

// For each physical face, define the outward normal and which way is "up"
// on that face's surface (so the text is oriented correctly).
const FACE_LABEL_ORIENTATIONS = {
  R: { normal: [ 1, 0, 0], up: [0, 1, 0] },
  L: { normal: [-1, 0, 0], up: [0, 1, 0] },
  U: { normal: [ 0, 1, 0], up: [0, 0,-1] },
  D: { normal: [ 0,-1, 0], up: [0, 0, 1] },
  F: { normal: [ 0, 0, 1], up: [0, 1, 0] },
  B: { normal: [ 0, 0,-1], up: [0, 1, 0] },
};

for (const [physFace, orient] of Object.entries(FACE_LABEL_ORIENTATIONS)) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;

  const material = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    depthTest: true,
    side: THREE.FrontSide,
  });

  const plane = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.7), material);

  // Position just outside the face center
  const n = new THREE.Vector3(...orient.normal);
  const u = new THREE.Vector3(...orient.up);
  const r = new THREE.Vector3().crossVectors(u, n);
  plane.position.copy(n.clone().multiplyScalar(LABEL_OFFSET));

  // Orient: build rotation from right/up/normal basis vectors
  const mat4 = new THREE.Matrix4().makeBasis(r, u, n);
  plane.quaternion.setFromRotationMatrix(mat4);

  faceLabelGroup.add(plane);
  faceLabels[physFace] = { mesh: plane, canvas, ctx, texture };
}

// Draw a letter on a face label canvas
function drawFaceLabel(physFace, letter) {
  const { canvas, ctx, texture } = faceLabels[physFace];
  ctx.clearRect(0, 0, 128, 128);

  // Semi-transparent dark circle background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
  ctx.beginPath();
  ctx.arc(64, 64, 48, 0, Math.PI * 2);
  ctx.fill();

  // White letter
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 60px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(letter, 64, 67);
  texture.needsUpdate = true;
}

let lastLabelMapStr = '';

function updateFaceLabels() {
  const viewMap = getViewFaces();

  // Build reverse map: physical face -> relative label (F, R, L, U, D, B)
  const reverseMap = {};
  for (const [rel, phys] of Object.entries(viewMap)) {
    reverseMap[phys] = rel;
  }

  // Only redraw if the mapping actually changed
  const mapStr = JSON.stringify(reverseMap);
  if (mapStr === lastLabelMapStr) return;
  lastLabelMapStr = mapStr;

  for (const [physFace, letter] of Object.entries(reverseMap)) {
    drawFaceLabel(physFace, letter);
  }
}

// Initial draw
updateFaceLabels();

// ─── FACE ROTATION ANIMATION ────────────────────────────────

let isAnimating = false;
const animationQueue = [];

const ANIM_DURATION = 250; // ms

const AXIS_VECTORS = {
  x: new THREE.Vector3(1, 0, 0),
  y: new THREE.Vector3(0, 1, 0),
  z: new THREE.Vector3(0, 0, 1),
};

function getCubiesOnLayer(axis, layer) {
  return cubies.filter(mesh => {
    const p = mesh.userData.pos;
    return Math.round(p[axis]) === layer;
  });
}

function rotateFace(faceName, clockwise = true, duration = ANIM_DURATION) {
  return new Promise(resolve => {
    const face = FACES[faceName];
    if (!face) { resolve(); return; }

    const { axis, layer, dir } = face;
    const angle = (clockwise ? -1 : 1) * dir * (Math.PI / 2);
    const axisVec = AXIS_VECTORS[axis];
    const layerCubies = getCubiesOnLayer(axis, layer);

    // Create a temporary pivot group
    const pivot = new THREE.Group();
    scene.add(pivot);

    // Reparent cubies to pivot
    for (const mesh of layerCubies) {
      cubieGroup.remove(mesh);
      pivot.add(mesh);
    }

    const startTime = performance.now();

    function animate(now) {
      const elapsed = now - startTime;
      const t = Math.min(elapsed / duration, 1);
      // Smooth easing (ease-in-out cubic)
      const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

      if (axis === 'x') pivot.rotation.x = angle * eased;
      if (axis === 'y') pivot.rotation.y = angle * eased;
      if (axis === 'z') pivot.rotation.z = angle * eased;

      if (t < 1) {
        requestAnimationFrame(animate);
      } else {
        // Finalize: apply rotation to each cubie and reparent back
        for (const mesh of layerCubies) {
          // Get world position & apply
          pivot.updateMatrixWorld();
          mesh.applyMatrix4(pivot.matrixWorld);
          mesh.position.sub(cubieGroup.position); // adjust for group offset

          pivot.remove(mesh);
          cubieGroup.add(mesh);

          // Snap position to grid
          const p = mesh.userData.pos;
          const pos = mesh.position;
          mesh.userData.pos = {
            x: Math.round(pos.x / STEP),
            y: Math.round(pos.y / STEP),
            z: Math.round(pos.z / STEP),
          };

          // Snap position
          mesh.position.set(
            mesh.userData.pos.x * STEP,
            mesh.userData.pos.y * STEP,
            mesh.userData.pos.z * STEP
          );
        }

        scene.remove(pivot);
        resolve();
      }
    }

    requestAnimationFrame(animate);
  });
}

// Also update the internal cubeState when rotating
function rotateCubeState(faceName, clockwise = true) {
  const face = cubeState[faceName];
  // Rotate the face itself (the 3x3 grid)
  if (clockwise) {
    const tmp = [
      [face[2][0], face[1][0], face[0][0]],
      [face[2][1], face[1][1], face[0][1]],
      [face[2][2], face[1][2], face[0][2]],
    ];
    for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) face[r][c] = tmp[r][c];
  } else {
    const tmp = [
      [face[0][2], face[1][2], face[2][2]],
      [face[0][1], face[1][1], face[2][1]],
      [face[0][0], face[1][0], face[2][0]],
    ];
    for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) face[r][c] = tmp[r][c];
  }

  // Rotate adjacent edges
  // This depends on which face. Each face rotation affects 4 adjacent strips.
  const s = cubeState;
  if (faceName === 'U') {
    if (clockwise) {
      const tmp = [s.F[0][0], s.F[0][1], s.F[0][2]];
      [s.F[0][0], s.F[0][1], s.F[0][2]] = [s.R[0][0], s.R[0][1], s.R[0][2]];
      [s.R[0][0], s.R[0][1], s.R[0][2]] = [s.B[0][0], s.B[0][1], s.B[0][2]];
      [s.B[0][0], s.B[0][1], s.B[0][2]] = [s.L[0][0], s.L[0][1], s.L[0][2]];
      [s.L[0][0], s.L[0][1], s.L[0][2]] = tmp;
    } else {
      const tmp = [s.F[0][0], s.F[0][1], s.F[0][2]];
      [s.F[0][0], s.F[0][1], s.F[0][2]] = [s.L[0][0], s.L[0][1], s.L[0][2]];
      [s.L[0][0], s.L[0][1], s.L[0][2]] = [s.B[0][0], s.B[0][1], s.B[0][2]];
      [s.B[0][0], s.B[0][1], s.B[0][2]] = [s.R[0][0], s.R[0][1], s.R[0][2]];
      [s.R[0][0], s.R[0][1], s.R[0][2]] = tmp;
    }
  } else if (faceName === 'D') {
    if (clockwise) {
      const tmp = [s.F[2][0], s.F[2][1], s.F[2][2]];
      [s.F[2][0], s.F[2][1], s.F[2][2]] = [s.L[2][0], s.L[2][1], s.L[2][2]];
      [s.L[2][0], s.L[2][1], s.L[2][2]] = [s.B[2][0], s.B[2][1], s.B[2][2]];
      [s.B[2][0], s.B[2][1], s.B[2][2]] = [s.R[2][0], s.R[2][1], s.R[2][2]];
      [s.R[2][0], s.R[2][1], s.R[2][2]] = tmp;
    } else {
      const tmp = [s.F[2][0], s.F[2][1], s.F[2][2]];
      [s.F[2][0], s.F[2][1], s.F[2][2]] = [s.R[2][0], s.R[2][1], s.R[2][2]];
      [s.R[2][0], s.R[2][1], s.R[2][2]] = [s.B[2][0], s.B[2][1], s.B[2][2]];
      [s.B[2][0], s.B[2][1], s.B[2][2]] = [s.L[2][0], s.L[2][1], s.L[2][2]];
      [s.L[2][0], s.L[2][1], s.L[2][2]] = tmp;
    }
  } else if (faceName === 'F') {
    if (clockwise) {
      const tmp = [s.U[2][0], s.U[2][1], s.U[2][2]];
      [s.U[2][0], s.U[2][1], s.U[2][2]] = [s.L[2][2], s.L[1][2], s.L[0][2]];
      [s.L[0][2], s.L[1][2], s.L[2][2]] = [s.D[0][0], s.D[0][1], s.D[0][2]];
      [s.D[0][0], s.D[0][1], s.D[0][2]] = [s.R[2][0], s.R[1][0], s.R[0][0]];
      [s.R[0][0], s.R[1][0], s.R[2][0]] = tmp;
    } else {
      const tmp = [s.U[2][0], s.U[2][1], s.U[2][2]];
      [s.U[2][0], s.U[2][1], s.U[2][2]] = [s.R[0][0], s.R[1][0], s.R[2][0]];
      [s.R[0][0], s.R[1][0], s.R[2][0]] = [s.D[0][2], s.D[0][1], s.D[0][0]];
      [s.D[0][0], s.D[0][1], s.D[0][2]] = [s.L[0][2], s.L[1][2], s.L[2][2]];
      [s.L[0][2], s.L[1][2], s.L[2][2]] = [tmp[2], tmp[1], tmp[0]];
    }
  } else if (faceName === 'B') {
    if (clockwise) {
      const tmp = [s.U[0][0], s.U[0][1], s.U[0][2]];
      [s.U[0][0], s.U[0][1], s.U[0][2]] = [s.R[0][2], s.R[1][2], s.R[2][2]];
      [s.R[0][2], s.R[1][2], s.R[2][2]] = [s.D[2][2], s.D[2][1], s.D[2][0]];
      [s.D[2][0], s.D[2][1], s.D[2][2]] = [s.L[0][0], s.L[1][0], s.L[2][0]];
      [s.L[0][0], s.L[1][0], s.L[2][0]] = [tmp[2], tmp[1], tmp[0]];
    } else {
      const tmp = [s.U[0][0], s.U[0][1], s.U[0][2]];
      [s.U[0][0], s.U[0][1], s.U[0][2]] = [s.L[2][0], s.L[1][0], s.L[0][0]];
      [s.L[0][0], s.L[1][0], s.L[2][0]] = [s.D[2][2], s.D[2][1], s.D[2][0]];
      [s.D[2][0], s.D[2][1], s.D[2][2]] = [s.R[2][2], s.R[1][2], s.R[0][2]];
      [s.R[0][2], s.R[1][2], s.R[2][2]] = tmp;
    }
  } else if (faceName === 'R') {
    if (clockwise) {
      const tmp = [s.U[0][2], s.U[1][2], s.U[2][2]];
      [s.U[0][2], s.U[1][2], s.U[2][2]] = [s.F[0][2], s.F[1][2], s.F[2][2]];
      [s.F[0][2], s.F[1][2], s.F[2][2]] = [s.D[0][2], s.D[1][2], s.D[2][2]];
      [s.D[0][2], s.D[1][2], s.D[2][2]] = [s.B[2][0], s.B[1][0], s.B[0][0]];
      [s.B[0][0], s.B[1][0], s.B[2][0]] = [tmp[2], tmp[1], tmp[0]];
    } else {
      const tmp = [s.U[0][2], s.U[1][2], s.U[2][2]];
      [s.U[0][2], s.U[1][2], s.U[2][2]] = [s.B[2][0], s.B[1][0], s.B[0][0]];
      [s.B[0][0], s.B[1][0], s.B[2][0]] = [s.D[2][2], s.D[1][2], s.D[0][2]];
      [s.D[0][2], s.D[1][2], s.D[2][2]] = [s.F[0][2], s.F[1][2], s.F[2][2]];
      [s.F[0][2], s.F[1][2], s.F[2][2]] = tmp;
    }
  } else if (faceName === 'L') {
    if (clockwise) {
      const tmp = [s.U[0][0], s.U[1][0], s.U[2][0]];
      [s.U[0][0], s.U[1][0], s.U[2][0]] = [s.B[2][2], s.B[1][2], s.B[0][2]];
      [s.B[0][2], s.B[1][2], s.B[2][2]] = [s.D[2][0], s.D[1][0], s.D[0][0]];
      [s.D[0][0], s.D[1][0], s.D[2][0]] = [s.F[0][0], s.F[1][0], s.F[2][0]];
      [s.F[0][0], s.F[1][0], s.F[2][0]] = tmp;
    } else {
      const tmp = [s.U[0][0], s.U[1][0], s.U[2][0]];
      [s.U[0][0], s.U[1][0], s.U[2][0]] = [s.F[0][0], s.F[1][0], s.F[2][0]];
      [s.F[0][0], s.F[1][0], s.F[2][0]] = [s.D[0][0], s.D[1][0], s.D[2][0]];
      [s.D[0][0], s.D[1][0], s.D[2][0]] = [s.B[2][2], s.B[1][2], s.B[0][2]];
      [s.B[0][2], s.B[1][2], s.B[2][2]] = [tmp[2], tmp[1], tmp[0]];
    }
  }
}

// Refresh cubie colors from cubeState
function refreshCubieColors() {
  for (const mesh of cubies) {
    const { x, y, z } = mesh.userData.pos;
    const mats = mesh.material;
    for (let i = 0; i < 6; i++) {
      mats[i].color.setHex(faceColorFromState(x, y, z, i));
    }
  }
}

function faceColorFromState(x, y, z, faceIndex) {
  const colorMap = { W: 0xffffff, Y: 0xffd500, G: 0x009b48, B: 0x0045ad, R: 0xc41e3a, O: 0xff5800 };
  let code = null;

  if (faceIndex === 0 && x === 1)  code = cubeState.R[1 - y][1 - z]; // +X = R face — but mapping is tricky
  if (faceIndex === 1 && x === -1) code = cubeState.L[1 - y][z + 1];
  if (faceIndex === 2 && y === 1)  code = cubeState.U[1 - z][x + 1];
  if (faceIndex === 3 && y === -1) code = cubeState.D[z + 1][x + 1];
  if (faceIndex === 4 && z === 1)  code = cubeState.F[1 - y][x + 1];
  if (faceIndex === 5 && z === -1) code = cubeState.B[1 - y][1 - x];

  if (code && colorMap[code] !== undefined) return colorMap[code];
  return INTERIOR_COLOR;
}

// ─── WHOLE-CUBE ROTATION (X / Y / Z) ────────────────────────

function rotateCubeStateWhole(axis, clockwise) {
  // Whole-cube rotation remaps ALL 6 faces.
  // X = around R-L axis, Y = around U-D axis, Z = around F-B axis
  const s = cubeState;

  // Helper: rotate a 3x3 face grid 90° clockwise
  function rotFaceCW(face) {
    const f = s[face];
    const tmp = [
      [f[2][0], f[1][0], f[0][0]],
      [f[2][1], f[1][1], f[0][1]],
      [f[2][2], f[1][2], f[0][2]],
    ];
    for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) f[r][c] = tmp[r][c];
  }
  function rotFaceCCW(face) {
    const f = s[face];
    const tmp = [
      [f[0][2], f[1][2], f[2][2]],
      [f[0][1], f[1][1], f[2][1]],
      [f[0][0], f[1][0], f[2][0]],
    ];
    for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) f[r][c] = tmp[r][c];
  }
  function rotFace180(face) { rotFaceCW(face); rotFaceCW(face); }
  // Copy a full face grid
  function copyFace(face) { return s[face].map(row => [...row]); }

  if (axis === 'y') {
    // Y rotation (clockwise looking down from top = F→R→B→L→F)
    if (clockwise) {
      const tmpF = copyFace('F');
      s.F = s.R.map(r => [...r]);
      s.R = s.B.map(r => [...r]);
      s.B = s.L.map(r => [...r]);
      s.L = tmpF.map(r => [...r]);
      rotFaceCW('U');
      rotFaceCCW('D');
    } else {
      const tmpF = copyFace('F');
      s.F = s.L.map(r => [...r]);
      s.L = s.B.map(r => [...r]);
      s.B = s.R.map(r => [...r]);
      s.R = tmpF.map(r => [...r]);
      rotFaceCCW('U');
      rotFaceCW('D');
    }
  } else if (axis === 'x') {
    // X rotation (clockwise looking from R side = U→F→D→B→U)
    // B face is stored mirrored relative to others, so need special handling
    if (clockwise) {
      const tmpU = copyFace('U');
      s.U = s.F.map(r => [...r]);
      s.F = s.D.map(r => [...r]);
      // D→B: need to flip both row and col order
      s.D = s.B.map(r => [...r]);
      rotFace180('D');
      // tmpU→B: need to flip both row and col order
      s.B = tmpU.map(r => [...r]);
      rotFace180('B');
      rotFaceCW('R');
      rotFaceCCW('L');
    } else {
      const tmpU = copyFace('U');
      // B→U: flip both
      s.U = s.B.map(r => [...r]);
      rotFace180('U');
      s.B = s.D.map(r => [...r]);
      rotFace180('B');
      s.D = s.F.map(r => [...r]);
      s.F = tmpU.map(r => [...r]);
      rotFaceCCW('R');
      rotFaceCW('L');
    }
  } else if (axis === 'z') {
    // Z rotation (clockwise looking at F face = U→R→D→L→U)
    // Need to rotate the face grids as they transfer between horizontal/vertical orientations
    if (clockwise) {
      const tmpU = copyFace('U');
      // L→U: rotate the grid CW
      s.U = s.L.map(r => [...r]); rotFaceCW('U');
      // D→L: rotate the grid CW
      s.L = s.D.map(r => [...r]); rotFaceCW('L');
      // R→D: rotate the grid CW
      s.D = s.R.map(r => [...r]); rotFaceCW('D');
      // tmpU→R: rotate CW
      s.R = tmpU.map(r => [...r]); rotFaceCW('R');
      rotFaceCW('F');
      rotFaceCCW('B');
    } else {
      const tmpU = copyFace('U');
      // R→U: rotate CCW
      s.U = s.R.map(r => [...r]); rotFaceCCW('U');
      // D→R: rotate CCW
      s.R = s.D.map(r => [...r]); rotFaceCCW('R');
      // L→D: rotate CCW
      s.D = s.L.map(r => [...r]); rotFaceCCW('D');
      // tmpU→L: rotate CCW
      s.L = tmpU.map(r => [...r]); rotFaceCCW('L');
      rotFaceCCW('F');
      rotFaceCW('B');
    }
  }
}

async function doWholeCubeRotation(axis, clockwise, duration = ANIM_DURATION) {
  if (isAnimating) return;
  isAnimating = true;

  // Update logical state
  rotateCubeStateWhole(axis, clockwise);

  // Animate all 27 cubies rotating around the axis
  const dir = { x: 1, y: 1, z: 1 }[axis]; // all axes use dir=1 for whole cube
  const angle = (clockwise ? -1 : 1) * (Math.PI / 2);
  const axisVec = AXIS_VECTORS[axis];

  const pivot = new THREE.Group();
  scene.add(pivot);

  const allCubies = [...cubies];
  for (const mesh of allCubies) {
    cubieGroup.remove(mesh);
    pivot.add(mesh);
  }

  const startTime = performance.now();

  await new Promise(resolve => {
    function animate(now) {
      const elapsed = now - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

      if (axis === 'x') pivot.rotation.x = angle * eased;
      if (axis === 'y') pivot.rotation.y = angle * eased;
      if (axis === 'z') pivot.rotation.z = angle * eased;

      if (t < 1) {
        requestAnimationFrame(animate);
      } else {
        for (const mesh of allCubies) {
          pivot.updateMatrixWorld();
          mesh.applyMatrix4(pivot.matrixWorld);
          mesh.position.sub(cubieGroup.position);
          pivot.remove(mesh);
          cubieGroup.add(mesh);

          mesh.userData.pos = {
            x: Math.round(mesh.position.x / STEP),
            y: Math.round(mesh.position.y / STEP),
            z: Math.round(mesh.position.z / STEP),
          };
          mesh.position.set(
            mesh.userData.pos.x * STEP,
            mesh.userData.pos.y * STEP,
            mesh.userData.pos.z * STEP
          );
        }
        scene.remove(pivot);
        resolve();
      }
    }
    requestAnimationFrame(animate);
  });

  // Force face label update
  lastLabelMapStr = '';
  updateFaceLabels();

  isAnimating = false;

  if (animationQueue.length > 0) {
    const next = animationQueue.shift();
    next();
  }
}

// ─── MOVE SYSTEM ─────────────────────────────────────────────

const moveHistory = [];
let redoStack = [];
let moveCount = 0;

function updateMoveCount() {
  document.getElementById('move-count').textContent = `Moves: ${moveCount}`;
}

async function doMove(faceName, clockwise = true, record = true, duration = ANIM_DURATION) {
  if (isAnimating) return;
  isAnimating = true;

  rotateCubeState(faceName, clockwise);
  await rotateFace(faceName, clockwise, duration);

  if (record) {
    moveHistory.push({ face: faceName, clockwise });
    redoStack = [];
    moveCount++;
    updateMoveCount();
  }

  isAnimating = false;

  // Process queue
  if (animationQueue.length > 0) {
    const next = animationQueue.shift();
    next();
  }
}

function queueMove(faceName, clockwise = true, record = true, duration = ANIM_DURATION) {
  if (isAnimating) {
    animationQueue.push(() => doMove(faceName, clockwise, record, duration));
  } else {
    doMove(faceName, clockwise, record, duration);
  }
}

// ─── UNDO / REDO ─────────────────────────────────────────────

async function undo() {
  if (moveHistory.length === 0 || isAnimating) return;
  const last = moveHistory.pop();
  redoStack.push(last);
  moveCount = Math.max(0, moveCount - 1);
  updateMoveCount();
  await doMove(last.face, !last.clockwise, false);
}

async function redo() {
  if (redoStack.length === 0 || isAnimating) return;
  const next = redoStack.pop();
  moveHistory.push(next);
  moveCount++;
  updateMoveCount();
  await doMove(next.face, next.clockwise, false);
}

// ─── SCRAMBLE ────────────────────────────────────────────────

const FACE_NAMES = ['U', 'D', 'R', 'L', 'F', 'B'];
const OPPOSITE = { U: 'D', D: 'U', R: 'L', L: 'R', F: 'B', B: 'F' };

function generateScramble(length = 20) {
  const moves = [];
  let lastFace = '';
  let secondLastFace = '';

  for (let i = 0; i < length; i++) {
    let face;
    do {
      face = FACE_NAMES[Math.floor(Math.random() * 6)];
    } while (face === lastFace || (face === OPPOSITE[lastFace] && secondLastFace === lastFace));

    const clockwise = Math.random() < 0.5;
    const double = Math.random() < 0.25; // 25% chance of double move

    moves.push({ face, clockwise });
    if (double) moves.push({ face, clockwise });

    secondLastFace = lastFace;
    lastFace = face;
  }
  return moves;
}

// Convert a move to cubejs notation string (e.g. "R" or "R'")
function moveToNotation(face, clockwise) {
  return face + (clockwise ? '' : "'");
}

// Build a cubejs move string from moveHistory (space-separated)
function moveHistoryToString() {
  return moveHistory.map(m => moveToNotation(m.face, m.clockwise)).join(' ');
}

function getAnimSpeed() {
  return parseInt(document.getElementById('speed-select').value, 10);
}

async function scramble() {
  if (isAnimating) return;
  const speed = getAnimSpeed();
  const moves = generateScramble(20);
  debugLog(`Scramble: ${moves.length} moves, speed=${speed}ms`);
  for (const move of moves) {
    await doMove(move.face, move.clockwise, true, speed);
  }
  debugLog('Scramble done');
}

// ─── RESET ───────────────────────────────────────────────────

function resetCube() {
  if (isAnimating) return;
  initCubeState();
  buildCube();
  moveHistory.length = 0;
  redoStack.length = 0;
  moveCount = 0;
  updateMoveCount();
}

// ─── CLICK-DRAG FACE ROTATION ────────────────────────────────

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let dragStart = null;
let dragCubie = null;
let dragFaceNormal = null;

function getIntersect(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  const clientX = event.touches ? event.touches[0].clientX : event.clientX;
  const clientY = event.touches ? event.touches[0].clientY : event.clientY;
  mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(cubies);
  return hits.length > 0 ? hits[0] : null;
}

function getFaceNormal(hit) {
  // Get the face normal in world space
  const normal = hit.face.normal.clone();
  normal.transformDirection(hit.object.matrixWorld);
  // Snap to nearest axis
  const abs = [Math.abs(normal.x), Math.abs(normal.y), Math.abs(normal.z)];
  const maxIdx = abs.indexOf(Math.max(...abs));
  const snapped = new THREE.Vector3();
  if (maxIdx === 0) snapped.x = Math.sign(normal.x);
  if (maxIdx === 1) snapped.y = Math.sign(normal.y);
  if (maxIdx === 2) snapped.z = Math.sign(normal.z);
  return snapped;
}

function determineMoveFromDrag(cubiePos, faceNormal, dragDir) {
  // When you drag a cubie, the drag direction shows which way you want
  // cubies to MOVE. The rotation axis is PERPENDICULAR to that motion.
  // So we pick the axis whose screen projection is most perpendicular
  // to the drag direction, and use the 2D cross product for CW/CCW.

  const candidates = [];

  // The two possible rotation axes are perpendicular to the clicked face
  const axes = [];
  if (Math.abs(faceNormal.x) > 0.5) { axes.push('y', 'z'); }
  else if (Math.abs(faceNormal.y) > 0.5) { axes.push('x', 'z'); }
  else { axes.push('x', 'y'); }

  for (const axis of axes) {
    const axisVec = AXIS_VECTORS[axis].clone();
    // Project axis direction to screen space
    const center = new THREE.Vector3(cubiePos.x * STEP, cubiePos.y * STEP, cubiePos.z * STEP);
    const p1 = center.clone().project(camera);
    const p2 = center.clone().add(axisVec).project(camera);
    const screenAxis = new THREE.Vector2(p2.x - p1.x, p2.y - p1.y).normalize();

    // Perpendicularity: how perpendicular is this axis to the drag?
    // |dot| near 0 = perpendicular (what we want), |dot| near 1 = parallel
    const dot = screenAxis.dot(dragDir);
    const perp = 1 - Math.abs(dot);

    // 2D cross product: determines rotation direction
    const cross = screenAxis.x * dragDir.y - screenAxis.y * dragDir.x;

    const layer = Math.round(cubiePos[axis]);

    for (const [name, f] of Object.entries(FACES)) {
      if (f.axis === axis && f.layer === layer) {
        candidates.push({ face: name, perp, clockwise: cross * f.dir > 0 });
      }
    }
  }

  if (candidates.length === 0) return null;
  // Pick the axis most perpendicular to the drag direction
  candidates.sort((a, b) => b.perp - a.perp);
  return candidates[0];
}

function onPointerDown(event) {
  if (showOffMode || crawlerMode) return;
  if (isAnimating || currentSolution) return;
  if (event.button && event.button !== 0) return; // left click only

  const hit = getIntersect(event);
  if (!hit) return;

  dragCubie = hit.object;
  dragFaceNormal = getFaceNormal(hit);

  const clientX = event.touches ? event.touches[0].clientX : event.clientX;
  const clientY = event.touches ? event.touches[0].clientY : event.clientY;
  dragStart = { x: clientX, y: clientY };

  // Disable orbit while dragging a face
  orbitControls.enabled = false;
}

function onPointerMove(event) {
  // We don't do anything here for now — the drag resolution happens on pointerup
}

function onPointerUp(event) {
  if (!dragStart || !dragCubie) {
    orbitControls.enabled = true;
    return;
  }

  const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
  const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
  const dx = clientX - dragStart.x;
  const dy = clientY - dragStart.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist > 15) {
    // Sufficient drag to trigger a move
    const dragDir = new THREE.Vector2(dx, -dy).normalize(); // flip Y for screen coords
    const move = determineMoveFromDrag(dragCubie.userData.pos, dragFaceNormal, dragDir);
    if (move) {
      queueMove(move.face, move.clockwise);
    }
  }

  dragStart = null;
  dragCubie = null;
  dragFaceNormal = null;
  orbitControls.enabled = true;
}

renderer.domElement.addEventListener('pointerdown', onPointerDown);
renderer.domElement.addEventListener('pointermove', onPointerMove);
renderer.domElement.addEventListener('pointerup', onPointerUp);
// Touch events for mobile
renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: true });
renderer.domElement.addEventListener('touchend', onPointerUp, { passive: true });

// ─── SOLVER: STATE CONVERSION & SOLUTION PARSING ─────────────

// Convert cubeState to the 54-char facelet string cubejs expects.
// Order: U1-U9, R1-R9, F1-F9, D1-D9, L1-L9, B1-B9 (row-major each face)
function cubeStateToFaceletString() {
  const colorToFacelet = { W: 'U', R: 'R', G: 'F', Y: 'D', O: 'L', B: 'B' };
  let str = '';
  // cubejs face order: U, R, F, D, L, B
  for (const face of ['U', 'R', 'F', 'D', 'L', 'B']) {
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        str += colorToFacelet[cubeState[face][r][c]];
      }
    }
  }
  return str;
}

// Parse a solution string like "R U R' F2 D' B" into move objects
function parseSolution(solutionStr) {
  if (!solutionStr || solutionStr.trim() === '') return [];
  const tokens = solutionStr.trim().split(/\s+/);
  const moves = [];
  for (const token of tokens) {
    const face = token[0]; // R, U, F, D, L, B
    if (!FACES[face]) continue;
    const isPrime = token.includes("'");
    const isDouble = token.includes('2');
    const clockwise = !isPrime;
    moves.push({ face, clockwise });
    if (isDouble) moves.push({ face, clockwise });
  }
  return moves;
}

// Check if cube is solved
function isCubeSolved() {
  for (const face of ['U', 'D', 'F', 'B', 'R', 'L']) {
    const center = cubeState[face][1][1];
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        if (cubeState[face][r][c] !== center) return false;
      }
    }
  }
  return true;
}

// ─── SOLVER: SOLVE & PLAYBACK ────────────────────────────────

async function solveCube() {
  if (isAnimating) {
    debugLog('solveCube: blocked by isAnimating');
    return;
  }
  if (!solverReady) {
    debugLog('solveCube: solver not ready yet');
    return;
  }

  if (isCubeSolved()) {
    showSolverStatus('Already solved!');
    debugLog('solveCube: already solved');
    return;
  }

  const btnSolve = document.getElementById('btn-solve');
  btnSolve.textContent = 'Solving...';
  btnSolve.disabled = true;

  // Yield so the browser can paint "Solving..." before we block
  await new Promise(r => setTimeout(r, 50));

  try {
    // Use move history to reconstruct state in cubejs's own move system.
    // This guarantees a valid cube state (our cubeState→facelet mapping has bugs).
    const movesStr = moveHistoryToString();
    debugLog(`solveCube: moves="${movesStr}" (${moveHistory.length} moves)`);
    const t0 = performance.now();

    let solution;
    if (solverWorkerReady) {
      // Use worker — non-blocking
      debugLog('solveCube: using worker (moves mode)');
      const result = await solveInWorker({ moves: movesStr });
      if (result.type === 'error') throw new Error(result.error);
      solution = result.solution;
    } else {
      // Main thread fallback — blocking
      debugLog('solveCube: using main thread (moves mode)');
      const cube = new Cube();
      cube.move(movesStr);
      solution = cube.solve();
    }

    const elapsed = (performance.now() - t0).toFixed(0);
    debugLog(`solveCube: solved in ${elapsed}ms → "${solution}"`);

    if (!solution || solution.trim() === '') {
      showSolverStatus('No solution found — cube may be in an invalid state');
      debugLog('solveCube: empty solution');
      btnSolve.textContent = 'Solve';
      btnSolve.disabled = false;
      return;
    }

    const moves = parseSolution(solution);
    debugLog(`solveCube: ${moves.length} moves`);
    currentSolution = { moves, index: 0, rawString: solution };
    showSolutionBar();
  } catch (err) {
    debugLog(`solveCube: ERROR: ${err.message}`);
    showSolverStatus('Solver error: ' + err.message);
  }

  btnSolve.textContent = 'Solve';
  btnSolve.disabled = false;
}

function showSolverStatus(msg) {
  // Brief overlay message
  const el = document.getElementById('solver-status');
  el.textContent = msg;
  el.style.display = 'block';
  setTimeout(() => { el.style.display = 'none'; }, 3000);
}

// ─── SOLUTION PLAYBACK ───────────────────────────────────────

function showSolutionBar() {
  const bar = document.getElementById('solution-bar');
  bar.style.display = 'flex';
  updateSolutionDisplay();
  setPlaybackLock(true);
}

function hideSolutionBar() {
  const bar = document.getElementById('solution-bar');
  bar.style.display = 'none';
  solutionPlaying = false;
  currentSolution = null;
  setPlaybackLock(false);
}

function setPlaybackLock(locked) {
  // During solution playback, disable scramble/reset/manual controls
  document.getElementById('btn-scramble').disabled = locked;
  document.getElementById('btn-reset').disabled = locked;
  document.getElementById('btn-undo').disabled = locked;
  document.getElementById('btn-redo').disabled = locked;
  document.getElementById('btn-solve').disabled = locked;
}

function updateSolutionDisplay() {
  if (!currentSolution) return;
  const { moves, index } = currentSolution;

  // Build move tokens display
  const tokensEl = document.getElementById('solution-tokens');
  tokensEl.innerHTML = '';

  // Convert moves back to notation for display
  const displayMoves = [];
  let i = 0;
  while (i < moves.length) {
    const m = moves[i];
    // Check if next move is same face+direction (double move)
    if (i + 1 < moves.length && moves[i + 1].face === m.face && moves[i + 1].clockwise === m.clockwise) {
      displayMoves.push({ text: m.face + '2', startIdx: i, endIdx: i + 1 });
      i += 2;
    } else {
      displayMoves.push({ text: m.face + (m.clockwise ? '' : "'"), startIdx: i, endIdx: i });
      i++;
    }
  }

  for (const dm of displayMoves) {
    const span = document.createElement('span');
    span.textContent = dm.text;
    span.className = 'sol-token';
    if (index > dm.endIdx) span.classList.add('sol-done');
    else if (index >= dm.startIdx && index <= dm.endIdx) span.classList.add('sol-current');
    tokensEl.appendChild(span);
  }

  // Update progress text
  document.getElementById('solution-progress').textContent = `${index} / ${moves.length}`;

  // Update play button text
  const playBtn = document.getElementById('sol-play');
  playBtn.textContent = solutionPlaying ? '⏸' : '▶';

  if (index >= moves.length) {
    showSolverStatus('Solved!');
  }
}

async function solutionStepForward() {
  if (!currentSolution || isAnimating) return;
  const { moves, index } = currentSolution;
  if (index >= moves.length) return;

  const move = moves[index];
  const speed = getAnimSpeed();
  await doMove(move.face, move.clockwise, false, speed);
  currentSolution.index++;
  updateSolutionDisplay();
}

async function solutionStepBack() {
  if (!currentSolution || isAnimating) return;
  const { moves, index } = currentSolution;
  if (index <= 0) return;

  currentSolution.index--;
  const move = moves[currentSolution.index];
  const speed = getAnimSpeed();
  // Undo = reverse the move
  await doMove(move.face, !move.clockwise, false, speed);
  updateSolutionDisplay();
}

async function solutionPlayPause() {
  if (!currentSolution) return;

  if (solutionPlaying) {
    solutionPlaying = false;
    updateSolutionDisplay();
    return;
  }

  solutionPlaying = true;
  updateSolutionDisplay();

  while (solutionPlaying && currentSolution && currentSolution.index < currentSolution.moves.length) {
    await solutionStepForward();
    // Small pause between moves during auto-play
    if (solutionPlaying) {
      await new Promise(r => setTimeout(r, 50));
    }
  }

  solutionPlaying = false;
  if (currentSolution) updateSolutionDisplay();
}

// ─── CAMERA ROTATION (ARROW KEYS & SNAP) ────────────────────

let isCameraAnimating = false;

function animateCameraRotation(axis, angle, duration = 300) {
  if (isCameraAnimating) return;
  isCameraAnimating = true;

  const startPos = camera.position.clone();
  const q = new THREE.Quaternion().setFromAxisAngle(axis, angle);
  const endPos = startPos.clone().applyQuaternion(q);

  const startTime = performance.now();
  function animate(now) {
    const t = Math.min((now - startTime) / duration, 1);
    const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    camera.position.lerpVectors(startPos, endPos, eased);
    camera.lookAt(0, 0, 0);
    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      camera.position.copy(endPos);
      camera.lookAt(0, 0, 0);
      isCameraAnimating = false;
    }
  }
  requestAnimationFrame(animate);
}

function snapToNearestCorner(duration = 400) {
  if (isCameraAnimating) return;
  isCameraAnimating = true;

  const dist = camera.position.length();
  const norm = camera.position.clone().normalize();

  // 8 corner viewing positions (all combos of ±1,±1,±1 normalized)
  const corners = [];
  for (const sx of [-1, 1]) {
    for (const sy of [-1, 1]) {
      for (const sz of [-1, 1]) {
        corners.push(new THREE.Vector3(sx, sy, sz).normalize());
      }
    }
  }

  // Find nearest corner by dot product (highest = closest direction)
  let bestCorner = corners[0];
  let bestDot = -2;
  for (const c of corners) {
    const d = norm.dot(c);
    if (d > bestDot) { bestDot = d; bestCorner = c; }
  }

  const startPos = camera.position.clone();
  const endPos = bestCorner.clone().multiplyScalar(dist);

  const startTime = performance.now();
  function animate(now) {
    const t = Math.min((now - startTime) / duration, 1);
    const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    camera.position.lerpVectors(startPos, endPos, eased);
    camera.lookAt(0, 0, 0);
    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      camera.position.copy(endPos);
      camera.lookAt(0, 0, 0);
      isCameraAnimating = false;
    }
  }
  requestAnimationFrame(animate);
}

// ─── KEYBOARD CONTROLS ──────────────────────────────────────

document.addEventListener('keydown', (e) => {
  // Crawler step mode — arrow keys step through solution
  if (crawlerMode && crawlerStepSolving && !crawlerBusy) {
    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
      e.preventDefault();
      crawlerStepForward();
      return;
    }
    if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
      e.preventDefault();
      crawlerStepBack();
      return;
    }
  }
  if (crawlerMode && crawlerStepSolving) return; // busy or in step mode

  // Crawler mode — arrow keys steer the cube, space spins
  if (crawlerMode && !crawlerBusy) {
    const speed = parseInt(document.getElementById('cr-speed').value) || 350;
    let dir = null;
    if (e.key === 'ArrowRight')  dir = '+x';
    if (e.key === 'ArrowLeft')   dir = '-x';
    if (e.key === 'ArrowDown')   dir = '+z';
    if (e.key === 'ArrowUp')     dir = '-z';
    if (dir) {
      e.preventDefault();
      const map = CRAWL_MAP[dir];
      const nx = crawlerGridX + map.dx;
      const nz = crawlerGridZ + map.dz;
      if (nx < 0 || nx >= crawlGrid || nz < 0 || nz >= crawlGrid) {
        updateCrawlerStatus('Edge of grid!');
        return;
      }
      crawlerBusy = true;
      crawlerCube.crawlMove(dir, speed).then(() => {
        crawlerGridX = nx;
        crawlerGridZ = nz;
        markTileVisited(nx, nz);
        crawlerBusy = false;
        crawlerMoveCount++;
        updateCrawlerMoveCount();
        updateCrawlerStatus(`Tile (${nx}, ${nz}) · Arrow keys to steer`);
      }).catch(() => { crawlerBusy = false; });
      return;
    }
    if (e.key === ' ') {
      e.preventDefault();
      crawlerBusy = true;
      crawlerCube.spinMove(!e.shiftKey, speed).then(() => {
        crawlerBusy = false;
        crawlerMoveCount++;
        updateCrawlerMoveCount();
        updateCrawlerStatus('Spin2! · Arrow keys to steer');
      }).catch(() => { crawlerBusy = false; });
      return;
    }
    if (e.key === 'Tab') {
      e.preventDefault();
      crawlerBusy = true;
      crawlerCube.spin1Move(!e.shiftKey, speed).then(() => {
        crawlerBusy = false;
        crawlerMoveCount++;
        updateCrawlerMoveCount();
        updateCrawlerStatus('Spin1! · Arrow keys to steer');
      }).catch(() => { crawlerBusy = false; });
      return;
    }
  }
  if (crawlerMode) return; // busy or unhandled key in crawler mode

  // Arrow keys — rotate camera view (always available, even during cube animation)
  if (e.key === 'ArrowLeft') {
    e.preventDefault();
    animateCameraRotation(new THREE.Vector3(0, 1, 0), Math.PI / 2);
    return;
  }
  if (e.key === 'ArrowRight') {
    e.preventDefault();
    animateCameraRotation(new THREE.Vector3(0, 1, 0), -Math.PI / 2);
    return;
  }
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    // Rotate around the camera's local X axis (horizontal axis perpendicular to view)
    const right = new THREE.Vector3();
    camera.getWorldDirection(right);
    right.cross(camera.up).normalize();
    animateCameraRotation(right, Math.PI / 6); // 30° to avoid flipping
    return;
  }
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    const right = new THREE.Vector3();
    camera.getWorldDirection(right);
    right.cross(camera.up).normalize();
    animateCameraRotation(right, -Math.PI / 6);
    return;
  }
  // Spacebar — snap to nearest clean 3-face view
  if (e.key === ' ') {
    e.preventDefault();
    snapToNearestCorner();
    return;
  }

  // Zoom: = (or +) zooms in, - zooms out
  if (e.key === '=' || e.key === '+') {
    e.preventDefault();
    const dir = camera.position.clone().normalize();
    const dist = camera.position.length();
    const newDist = Math.max(dist - 1.5, orbitControls.minDistance);
    camera.position.copy(dir.multiplyScalar(newDist));
    return;
  }
  if (e.key === '-' || e.key === '_') {
    e.preventDefault();
    const dir = camera.position.clone().normalize();
    const dist = camera.position.length();
    const newDist = Math.min(dist + 1.5, orbitControls.maxDistance);
    camera.position.copy(dir.multiplyScalar(newDist));
    return;
  }

  if (isAnimating) return;

  // Block manual moves during solution playback, show-off mode, or crawler mode
  if (currentSolution || showOffMode || crawlerMode) return;

  const key = e.key.toUpperCase();
  const clockwise = !e.shiftKey;

  // X/Y/Z — whole-cube rotation
  if (key === 'X' || key === 'Y' || key === 'Z') {
    e.preventDefault();
    doWholeCubeRotation(key.toLowerCase(), clockwise);
    return;
  }

  if (FACES[key]) {
    e.preventDefault();
    // Map the relative face key to the physical face based on camera view
    const viewMap = getViewFaces();
    const physicalFace = viewMap[key] || key;
    queueMove(physicalFace, clockwise);
  }
  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    if (e.shiftKey) redo();
    else undo();
  }
});

// ─── BUTTON CONTROLS ─────────────────────────────────────────

const faceControlsDiv = document.getElementById('face-controls');
const RELATIVE_LABELS = { F: 'Front', B: 'Back', U: 'Up', D: 'Down', R: 'Right', L: 'Left' };
const RELATIVE_FACES = ['F', 'B', 'U', 'D', 'R', 'L'];
const faceButtons = []; // track buttons for label updates

for (const rel of RELATIVE_FACES) {
  const cwBtn = document.createElement('button');
  cwBtn.className = 'face-btn';
  cwBtn.textContent = rel;
  cwBtn.title = `${RELATIVE_LABELS[rel]} clockwise`;
  cwBtn.addEventListener('click', () => {
    const phys = getViewFaces()[rel];
    queueMove(phys, true);
  });

  const ccwBtn = document.createElement('button');
  ccwBtn.className = 'face-btn';
  ccwBtn.textContent = rel + "'";
  ccwBtn.title = `${RELATIVE_LABELS[rel]} counter-clockwise`;
  ccwBtn.addEventListener('click', () => {
    const phys = getViewFaces()[rel];
    queueMove(phys, false);
  });

  faceControlsDiv.appendChild(cwBtn);
  faceControlsDiv.appendChild(ccwBtn);
  faceButtons.push({ rel, cwBtn, ccwBtn });
}

// Update face button tooltips to show which physical face they map to
function updateFaceButtonLabels() {
  const viewMap = getViewFaces();
  for (const { rel, cwBtn, ccwBtn } of faceButtons) {
    const phys = viewMap[rel];
    cwBtn.title = `${RELATIVE_LABELS[rel]} (${phys}) clockwise`;
    ccwBtn.title = `${RELATIVE_LABELS[rel]} (${phys}) counter-clockwise`;
  }
}

// Button labels are updated in the render loop via updateFaceLabels()
// (which already runs every frame). But we also need to update these
// button tooltips, so we hook into the same cycle.


document.getElementById('btn-toggle-face-controls').addEventListener('click', () => {
  faceControlsDiv.classList.toggle('visible');
});

// Wire up main buttons
document.getElementById('btn-undo').addEventListener('click', undo);
document.getElementById('btn-redo').addEventListener('click', redo);
document.getElementById('btn-reset').addEventListener('click', resetCube);
document.getElementById('btn-scramble').addEventListener('click', scramble);
document.getElementById('btn-flip').addEventListener('click', async () => {
  // Flip = x2 (two x rotations = cube upside down)
  await doWholeCubeRotation('x', true);
  await doWholeCubeRotation('x', true);
});

document.getElementById('btn-solve').addEventListener('click', solveCube);

// Solution bar buttons
document.getElementById('sol-prev').addEventListener('click', solutionStepBack);
document.getElementById('sol-play').addEventListener('click', solutionPlayPause);
document.getElementById('sol-next').addEventListener('click', solutionStepForward);
document.getElementById('sol-dismiss').addEventListener('click', hideSolutionBar);

document.getElementById('btn-help').addEventListener('click', () => {
  alert(
    'Face Controls (camera-relative):\n\n' +
    'F, R, L, U, D, B — Rotate face clockwise\n' +
    'Shift + key — Counter-clockwise\n' +
    '  (F = face you\'re looking at, R = right side, etc.)\n\n' +
    'Whole-Cube Rotation:\n' +
    'X — Tip cube forward (Shift+X = backward)\n' +
    'Y — Spin cube right (Shift+Y = left)\n' +
    'Z — Roll cube clockwise (Shift+Z = counter)\n' +
    'Flip button — Flip cube upside-down\n\n' +
    'Camera Controls:\n' +
    'Arrow Left/Right — Rotate view horizontally\n' +
    'Arrow Up/Down — Tilt view vertically\n' +
    'Spacebar — Snap to nearest 3-face view\n\n' +
    'Other:\n' +
    'Ctrl/Cmd + Z — Undo\n' +
    'Ctrl/Cmd + Shift + Z — Redo\n' +
    'Speed dropdown — Controls scramble/solve speed\n\n' +
    'Mouse/Touch:\n' +
    'Click & drag on a face to rotate it\n' +
    'Click & drag empty space to orbit\n' +
    'Scroll to zoom'
  );
});

// ─── SHOW OFF MODE ───────────────────────────────────────────

let showOffMode = false;
let showOffCubes = [];
let showOffBusy = false;
let continuousMode = false;
let continuousRunning = false;

function enterShowOffMode() {
  if (showOffMode || crawlerMode) return;
  showOffMode = true;

  // Hide normal UI
  document.getElementById('bottom-bar').style.display = 'none';
  document.getElementById('info-overlay').style.display = 'none';
  cubieGroup.visible = false;
  faceLabelGroup.visible = false;

  // Show showoff bar
  document.getElementById('showoff-bar').classList.add('visible');

  // Hide show off button, show nothing special in top bar
  document.getElementById('btn-showoff').style.display = 'none';
  document.getElementById('btn-toggle-face-controls').style.display = 'none';

  debugLog('Entered show-off mode');

  // Build default 3×3 grid
  createShowOffGrid(3);
}

function exitShowOffMode() {
  if (!showOffMode) return;

  // Stop continuous mode
  continuousMode = false;
  document.getElementById('so-continuous').checked = false;

  // Clear confetti and show-off cubes
  confettiSystem.clear();
  clearShowOffGrid();

  showOffMode = false;

  // Restore normal UI
  document.getElementById('bottom-bar').style.display = '';
  document.getElementById('info-overlay').style.display = '';
  cubieGroup.visible = true;
  faceLabelGroup.visible = true;

  // Hide showoff bar
  document.getElementById('showoff-bar').classList.remove('visible');

  // Restore buttons
  document.getElementById('btn-showoff').style.display = '';
  document.getElementById('btn-toggle-face-controls').style.display = '';

  // Reset camera
  animateCameraToPosition(new THREE.Vector3(6, 5, 6), 500);
  orbitControls.minDistance = 4;
  orbitControls.maxDistance = 15;
}

function animateCameraToPosition(targetPos, duration = 500) {
  if (isCameraAnimating) return;
  isCameraAnimating = true;
  const startPos = camera.position.clone();
  const startTime = performance.now();
  function animate(now) {
    const t = Math.min((now - startTime) / duration, 1);
    const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    camera.position.lerpVectors(startPos, targetPos, eased);
    camera.lookAt(0, 0, 0);
    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      camera.position.copy(targetPos);
      camera.lookAt(0, 0, 0);
      isCameraAnimating = false;
    }
  }
  requestAnimationFrame(animate);
}

// ─── SHOW OFF CUBE CLASS ─────────────────────────────────────

// Shared geometry for performance (all show-off cubies reuse this)
const sharedCubieGeo = new RoundedBoxGeometry(CUBIE_SIZE, CUBIE_SIZE, CUBIE_SIZE, CORNER_SEGMENTS, CORNER_RADIUS);

class ShowOffCube {
  constructor(position) {
    this.group = new THREE.Group();
    this.group.position.copy(position);
    scene.add(this.group);

    this.cubies = [];
    this.cubeState = {};
    this._activeRotation = null;

    this.initState();
    this.buildCubies();
  }

  initState() {
    for (const [face, code] of Object.entries(COLOR_CODE_MAP)) {
      this.cubeState[face] = Array.from({ length: 3 }, () => Array(3).fill(code));
    }
    this.moveSequence = ''; // Track moves for cubejs solver (guaranteed valid state)
    this.pipeline = { phase: 'idle', moves: [], moveIndex: 0 };
  }

  faceColor(x, y, z, fi) {
    if (fi === 0 && x ===  1) return FACE_COLORS.R;
    if (fi === 1 && x === -1) return FACE_COLORS.L;
    if (fi === 2 && y ===  1) return FACE_COLORS.U;
    if (fi === 3 && y === -1) return FACE_COLORS.D;
    if (fi === 4 && z ===  1) return FACE_COLORS.F;
    if (fi === 5 && z === -1) return FACE_COLORS.B;
    return INTERIOR_COLOR;
  }

  buildCubies() {
    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          const materials = [];
          for (let i = 0; i < 6; i++) {
            const color = this.faceColor(x, y, z, i);
            materials.push(new THREE.MeshStandardMaterial({
              color,
              roughness: color === INTERIOR_COLOR ? 0.9 : 0.35,
              metalness: color === INTERIOR_COLOR ? 0.0 : 0.05,
            }));
          }
          const mesh = new THREE.Mesh(sharedCubieGeo, materials);
          mesh.position.set(x * STEP, y * STEP, z * STEP);
          mesh.castShadow = false;  // perf: no shadows for show-off cubies
          mesh.receiveShadow = false;
          mesh.userData.pos = { x, y, z };
          this.group.add(mesh);
          this.cubies.push(mesh);
        }
      }
    }
  }

  reset() {
    // Cancel any in-progress animation
    if (this._activeRotation) {
      this._finishRotation();
    }
    // Remove old cubies
    for (const mesh of this.cubies) {
      mesh.material.forEach(m => m.dispose());
      this.group.remove(mesh);
    }
    this.cubies.length = 0;
    // Reset state and rebuild
    this.initState();
    this.buildCubies();
  }

  dispose() {
    // Cancel any in-progress animation
    if (this._activeRotation) {
      this._finishRotation();
    }
    for (const mesh of this.cubies) {
      mesh.material.forEach(m => m.dispose());
      this.group.remove(mesh);
    }
    this.cubies.length = 0;
    scene.remove(this.group);
  }

  getCubiesOnLayer(axis, layer) {
    return this.cubies.filter(m => Math.round(m.userData.pos[axis]) === layer);
  }

  rotateCubeState(faceName, clockwise) {
    const face = this.cubeState[faceName];
    if (clockwise) {
      const tmp = [
        [face[2][0], face[1][0], face[0][0]],
        [face[2][1], face[1][1], face[0][1]],
        [face[2][2], face[1][2], face[0][2]],
      ];
      for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) face[r][c] = tmp[r][c];
    } else {
      const tmp = [
        [face[0][2], face[1][2], face[2][2]],
        [face[0][1], face[1][1], face[2][1]],
        [face[0][0], face[1][0], face[2][0]],
      ];
      for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) face[r][c] = tmp[r][c];
    }

    // Adjacent edge rotation (same as global rotateCubeState)
    const s = this.cubeState;
    if (faceName === 'U') {
      if (clockwise) {
        const tmp = [s.F[0][0], s.F[0][1], s.F[0][2]];
        [s.F[0][0], s.F[0][1], s.F[0][2]] = [s.R[0][0], s.R[0][1], s.R[0][2]];
        [s.R[0][0], s.R[0][1], s.R[0][2]] = [s.B[0][0], s.B[0][1], s.B[0][2]];
        [s.B[0][0], s.B[0][1], s.B[0][2]] = [s.L[0][0], s.L[0][1], s.L[0][2]];
        [s.L[0][0], s.L[0][1], s.L[0][2]] = tmp;
      } else {
        const tmp = [s.F[0][0], s.F[0][1], s.F[0][2]];
        [s.F[0][0], s.F[0][1], s.F[0][2]] = [s.L[0][0], s.L[0][1], s.L[0][2]];
        [s.L[0][0], s.L[0][1], s.L[0][2]] = [s.B[0][0], s.B[0][1], s.B[0][2]];
        [s.B[0][0], s.B[0][1], s.B[0][2]] = [s.R[0][0], s.R[0][1], s.R[0][2]];
        [s.R[0][0], s.R[0][1], s.R[0][2]] = tmp;
      }
    } else if (faceName === 'D') {
      if (clockwise) {
        const tmp = [s.F[2][0], s.F[2][1], s.F[2][2]];
        [s.F[2][0], s.F[2][1], s.F[2][2]] = [s.L[2][0], s.L[2][1], s.L[2][2]];
        [s.L[2][0], s.L[2][1], s.L[2][2]] = [s.B[2][0], s.B[2][1], s.B[2][2]];
        [s.B[2][0], s.B[2][1], s.B[2][2]] = [s.R[2][0], s.R[2][1], s.R[2][2]];
        [s.R[2][0], s.R[2][1], s.R[2][2]] = tmp;
      } else {
        const tmp = [s.F[2][0], s.F[2][1], s.F[2][2]];
        [s.F[2][0], s.F[2][1], s.F[2][2]] = [s.R[2][0], s.R[2][1], s.R[2][2]];
        [s.R[2][0], s.R[2][1], s.R[2][2]] = [s.B[2][0], s.B[2][1], s.B[2][2]];
        [s.B[2][0], s.B[2][1], s.B[2][2]] = [s.L[2][0], s.L[2][1], s.L[2][2]];
        [s.L[2][0], s.L[2][1], s.L[2][2]] = tmp;
      }
    } else if (faceName === 'F') {
      if (clockwise) {
        const tmp = [s.U[2][0], s.U[2][1], s.U[2][2]];
        [s.U[2][0], s.U[2][1], s.U[2][2]] = [s.L[2][2], s.L[1][2], s.L[0][2]];
        [s.L[0][2], s.L[1][2], s.L[2][2]] = [s.D[0][0], s.D[0][1], s.D[0][2]];
        [s.D[0][0], s.D[0][1], s.D[0][2]] = [s.R[2][0], s.R[1][0], s.R[0][0]];
        [s.R[0][0], s.R[1][0], s.R[2][0]] = tmp;
      } else {
        const tmp = [s.U[2][0], s.U[2][1], s.U[2][2]];
        [s.U[2][0], s.U[2][1], s.U[2][2]] = [s.R[0][0], s.R[1][0], s.R[2][0]];
        [s.R[0][0], s.R[1][0], s.R[2][0]] = [s.D[0][2], s.D[0][1], s.D[0][0]];
        [s.D[0][0], s.D[0][1], s.D[0][2]] = [s.L[0][2], s.L[1][2], s.L[2][2]];
        [s.L[0][2], s.L[1][2], s.L[2][2]] = [tmp[2], tmp[1], tmp[0]];
      }
    } else if (faceName === 'B') {
      if (clockwise) {
        const tmp = [s.U[0][0], s.U[0][1], s.U[0][2]];
        [s.U[0][0], s.U[0][1], s.U[0][2]] = [s.R[0][2], s.R[1][2], s.R[2][2]];
        [s.R[0][2], s.R[1][2], s.R[2][2]] = [s.D[2][2], s.D[2][1], s.D[2][0]];
        [s.D[2][0], s.D[2][1], s.D[2][2]] = [s.L[0][0], s.L[1][0], s.L[2][0]];
        [s.L[0][0], s.L[1][0], s.L[2][0]] = [tmp[2], tmp[1], tmp[0]];
      } else {
        const tmp = [s.U[0][0], s.U[0][1], s.U[0][2]];
        [s.U[0][0], s.U[0][1], s.U[0][2]] = [s.L[2][0], s.L[1][0], s.L[0][0]];
        [s.L[0][0], s.L[1][0], s.L[2][0]] = [s.D[2][2], s.D[2][1], s.D[2][0]];
        [s.D[2][0], s.D[2][1], s.D[2][2]] = [s.R[2][2], s.R[1][2], s.R[0][2]];
        [s.R[0][2], s.R[1][2], s.R[2][2]] = tmp;
      }
    } else if (faceName === 'R') {
      if (clockwise) {
        const tmp = [s.U[0][2], s.U[1][2], s.U[2][2]];
        [s.U[0][2], s.U[1][2], s.U[2][2]] = [s.F[0][2], s.F[1][2], s.F[2][2]];
        [s.F[0][2], s.F[1][2], s.F[2][2]] = [s.D[0][2], s.D[1][2], s.D[2][2]];
        [s.D[0][2], s.D[1][2], s.D[2][2]] = [s.B[2][0], s.B[1][0], s.B[0][0]];
        [s.B[0][0], s.B[1][0], s.B[2][0]] = [tmp[2], tmp[1], tmp[0]];
      } else {
        const tmp = [s.U[0][2], s.U[1][2], s.U[2][2]];
        [s.U[0][2], s.U[1][2], s.U[2][2]] = [s.B[2][0], s.B[1][0], s.B[0][0]];
        [s.B[0][0], s.B[1][0], s.B[2][0]] = [s.D[2][2], s.D[1][2], s.D[0][2]];
        [s.D[0][2], s.D[1][2], s.D[2][2]] = [s.F[0][2], s.F[1][2], s.F[2][2]];
        [s.F[0][2], s.F[1][2], s.F[2][2]] = tmp;
      }
    } else if (faceName === 'L') {
      if (clockwise) {
        const tmp = [s.U[0][0], s.U[1][0], s.U[2][0]];
        [s.U[0][0], s.U[1][0], s.U[2][0]] = [s.B[2][2], s.B[1][2], s.B[0][2]];
        [s.B[0][2], s.B[1][2], s.B[2][2]] = [s.D[2][0], s.D[1][0], s.D[0][0]];
        [s.D[0][0], s.D[1][0], s.D[2][0]] = [s.F[0][0], s.F[1][0], s.F[2][0]];
        [s.F[0][0], s.F[1][0], s.F[2][0]] = tmp;
      } else {
        const tmp = [s.U[0][0], s.U[1][0], s.U[2][0]];
        [s.U[0][0], s.U[1][0], s.U[2][0]] = [s.F[0][0], s.F[1][0], s.F[2][0]];
        [s.F[0][0], s.F[1][0], s.F[2][0]] = [s.D[0][0], s.D[1][0], s.D[2][0]];
        [s.D[0][0], s.D[1][0], s.D[2][0]] = [s.B[2][2], s.B[1][2], s.B[0][2]];
        [s.B[0][2], s.B[1][2], s.B[2][2]] = [tmp[2], tmp[1], tmp[0]];
      }
    }
  }

  // Set up a rotation — driven by the main tick() loop, NOT its own rAF
  rotateFace(faceName, clockwise, duration) {
    return new Promise(resolve => {
      const faceInfo = FACES[faceName];
      if (!faceInfo) { resolve(); return; }

      const { axis, layer, dir } = faceInfo;
      const angle = (clockwise ? -1 : 1) * dir * (Math.PI / 2);
      const layerCubies = this.getCubiesOnLayer(axis, layer);

      if (layerCubies.length === 0) { resolve(); return; }

      const pivot = new THREE.Group();
      this.group.add(pivot);

      for (const mesh of layerCubies) {
        this.group.remove(mesh);
        pivot.add(mesh);
      }

      // Store as active rotation — tick() will drive the animation
      this._activeRotation = {
        axis, angle, pivot, layerCubies, resolve,
        startTime: performance.now(),
        duration: Math.max(duration, 1),
      };
    });
  }

  // Called every frame from the main tick() loop
  updateAnimation(now) {
    const r = this._activeRotation;
    if (!r) return;

    const t = Math.min((now - r.startTime) / r.duration, 1);
    const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

    if (r.axis === 'x') r.pivot.rotation.x = r.angle * eased;
    if (r.axis === 'y') r.pivot.rotation.y = r.angle * eased;
    if (r.axis === 'z') r.pivot.rotation.z = r.angle * eased;

    if (t >= 1) {
      this._finishRotation();
    }
  }

  _finishRotation() {
    const r = this._activeRotation;
    if (!r) return;
    this._activeRotation = null;

    // Compute pivot world matrix once (same approach as the working global rotateFace)
    r.pivot.updateMatrixWorld(true);

    for (const mesh of r.layerCubies) {
      mesh.applyMatrix4(r.pivot.matrixWorld);
      mesh.position.sub(this.group.position);

      r.pivot.remove(mesh);
      this.group.add(mesh);

      // Snap position to grid
      mesh.userData.pos = {
        x: Math.round(mesh.position.x / STEP),
        y: Math.round(mesh.position.y / STEP),
        z: Math.round(mesh.position.z / STEP),
      };
      mesh.position.set(
        mesh.userData.pos.x * STEP,
        mesh.userData.pos.y * STEP,
        mesh.userData.pos.z * STEP
      );
    }
    this.group.remove(r.pivot);
    r.resolve();
  }

  async doMove(faceName, clockwise, duration) {
    this.rotateCubeState(faceName, clockwise);
    // Track move for cubejs solver (bypasses our cubeState→facelet mapping)
    const notation = faceName + (clockwise ? '' : "'");
    this.moveSequence += (this.moveSequence ? ' ' : '') + notation;
    return this.rotateFace(faceName, clockwise, duration);
  }

  toFaceletString() {
    const colorToFacelet = { W: 'U', R: 'R', G: 'F', Y: 'D', O: 'L', B: 'B' };
    let str = '';
    for (const face of ['U', 'R', 'F', 'D', 'L', 'B']) {
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          str += colorToFacelet[this.cubeState[face][r][c]];
        }
      }
    }
    return str;
  }

  isSolved() {
    for (const face of ['U', 'D', 'F', 'B', 'R', 'L']) {
      const center = this.cubeState[face][1][1];
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (this.cubeState[face][r][c] !== center) return false;
        }
      }
    }
    return true;
  }
}

// ─── CRAWLER CUBE CLASS ─────────────────────────────────────

const CRAWL_MAP = {
  '+x': { face1: 'F', cw1: true,  face2: 'B', cw2: false, dx:  1, dz:  0, axis: 'z', sign: -1 },
  '-x': { face1: 'F', cw1: false, face2: 'B', cw2: true,  dx: -1, dz:  0, axis: 'z', sign:  1 },
  '+z': { face1: 'R', cw1: false, face2: 'L', cw2: true,  dx:  0, dz:  1, axis: 'x', sign:  1 },
  '-z': { face1: 'R', cw1: true,  face2: 'L', cw2: false, dx:  0, dz: -1, axis: 'x', sign: -1 },
};

const CRAWL_TILE_SIZE = 2 * STEP + CUBIE_SIZE; // 3.12 — matches cube width
const TILE_GAP = 0.1;
let crawlGrid = 8;

const CRAWLER_INVERSE = {
  '+x': '-x', '-x': '+x', '+z': '-z', '-z': '+z',
  'spin2': "spin2'", "spin2'": 'spin2',
  'spin1': "spin1'", "spin1'": 'spin1',
};
const ALL_CRAWLER_MOVES = ['+x', '-x', '+z', '-z', 'spin2', "spin2'", 'spin1', "spin1'"];

function generateCrawlerScramble(numMoves, startX, startZ) {
  const moves = [];
  let gx = startX, gz = startZ;
  let consecutiveSpins = 0;

  for (let i = 0; i < numMoves; i++) {
    // Filter moves by grid bounds and avoid undoing the last move
    const lastMove = moves.length > 0 ? moves[moves.length - 1] : null;
    const candidates = ALL_CRAWLER_MOVES.filter(m => {
      // Don't immediately undo the last move
      if (lastMove && CRAWLER_INVERSE[m] === lastMove) return false;
      // Cap consecutive spins at 2
      if (m.startsWith('spin') && consecutiveSpins >= 2) return false;
      // Check grid bounds for directional moves
      const map = CRAWL_MAP[m];
      if (map) {
        const nx = gx + map.dx, nz = gz + map.dz;
        if (nx < 0 || nx >= crawlGrid || nz < 0 || nz >= crawlGrid) return false;
      }
      return true;
    });
    const move = candidates[Math.floor(Math.random() * candidates.length)];
    moves.push(move);
    // Update grid position for directional moves
    const map = CRAWL_MAP[move];
    if (map) {
      gx += map.dx;
      gz += map.dz;
      consecutiveSpins = 0;
    } else {
      consecutiveSpins++;
    }
  }
  return moves;
}

function optimizeCrawlerSolution(moves) {
  let changed = true;
  while (changed) {
    changed = false;
    // Cancel adjacent inverse pairs
    for (let i = 0; i < moves.length - 1; i++) {
      if (CRAWLER_INVERSE[moves[i]] === moves[i + 1]) {
        moves.splice(i, 2);
        changed = true;
        break;
      }
    }
    // Collapse 4 identical spins → nothing
    for (let i = 0; i <= moves.length - 4 && !changed; i++) {
      if (moves[i].startsWith('spin') &&
          moves[i] === moves[i+1] && moves[i] === moves[i+2] && moves[i] === moves[i+3]) {
        moves.splice(i, 4);
        changed = true;
      }
    }
    // Collapse 3 identical spins → 1 inverse spin
    for (let i = 0; i <= moves.length - 3 && !changed; i++) {
      if (moves[i].startsWith('spin') &&
          moves[i] === moves[i+1] && moves[i] === moves[i+2]) {
        moves.splice(i, 3, CRAWLER_INVERSE[moves[i]]);
        changed = true;
      }
    }
  }
  return moves;
}

function generateCrawlerSolution(scrambleMoves) {
  const reversed = [...scrambleMoves].reverse().map(m => CRAWLER_INVERSE[m]);
  return optimizeCrawlerSolution(reversed);
}

class CrawlerCube {
  constructor(position) {
    this.group = new THREE.Group();
    this.group.position.copy(position);
    scene.add(this.group);
    this.cubies = [];
    this.cubeState = {};
    this.moveSequence = [];
    this.crawlerHistory = [];
    this._activeCrawl = null;
    this.initState();
    this.buildCubies();
  }

  initState() {
    for (const [face, code] of Object.entries(COLOR_CODE_MAP)) {
      this.cubeState[face] = Array.from({ length: 3 }, () => Array(3).fill(code));
    }
    this.moveSequence = [];
    this.crawlerHistory = [];
  }

  isSolved() {
    for (const face of ['U', 'D', 'F', 'B', 'R', 'L']) {
      const center = this.cubeState[face][1][1];
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
          if (this.cubeState[face][r][c] !== center) return false;
        }
      }
    }
    return true;
  }

  faceColor(x, y, z, fi) {
    if (fi === 0 && x ===  1) return FACE_COLORS.R;
    if (fi === 1 && x === -1) return FACE_COLORS.L;
    if (fi === 2 && y ===  1) return FACE_COLORS.U;
    if (fi === 3 && y === -1) return FACE_COLORS.D;
    if (fi === 4 && z ===  1) return FACE_COLORS.F;
    if (fi === 5 && z === -1) return FACE_COLORS.B;
    return INTERIOR_COLOR;
  }

  buildCubies() {
    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          const materials = [];
          for (let i = 0; i < 6; i++) {
            const color = this.faceColor(x, y, z, i);
            materials.push(new THREE.MeshStandardMaterial({
              color,
              roughness: color === INTERIOR_COLOR ? 0.9 : 0.35,
              metalness: color === INTERIOR_COLOR ? 0.0 : 0.05,
            }));
          }
          const mesh = new THREE.Mesh(sharedCubieGeo, materials);
          mesh.position.set(x * STEP, y * STEP, z * STEP);
          mesh.castShadow = false;
          mesh.receiveShadow = false;
          mesh.userData.pos = { x, y, z };
          this.group.add(mesh);
          this.cubies.push(mesh);
        }
      }
    }
  }

  reset() {
    if (this._activeCrawl) this._finishCrawl();
    for (const mesh of this.cubies) {
      mesh.material.forEach(m => m.dispose());
      this.group.remove(mesh);
    }
    this.cubies.length = 0;
    this.initState();  // also clears crawlerHistory
    this.buildCubies();
  }

  dispose() {
    if (this._activeCrawl) this._finishCrawl();
    for (const mesh of this.cubies) {
      mesh.material.forEach(m => m.dispose());
      this.group.remove(mesh);
    }
    this.cubies.length = 0;
    scene.remove(this.group);
  }

  getCubiesOnLayer(axis, layer) {
    return this.cubies.filter(m => Math.round(m.userData.pos[axis]) === layer);
  }

  rotateCubeState(faceName, clockwise) {
    const face = this.cubeState[faceName];
    if (clockwise) {
      const tmp = [
        [face[2][0], face[1][0], face[0][0]],
        [face[2][1], face[1][1], face[0][1]],
        [face[2][2], face[1][2], face[0][2]],
      ];
      for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) face[r][c] = tmp[r][c];
    } else {
      const tmp = [
        [face[0][2], face[1][2], face[2][2]],
        [face[0][1], face[1][1], face[2][1]],
        [face[0][0], face[1][0], face[2][0]],
      ];
      for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) face[r][c] = tmp[r][c];
    }
    // Adjacent edges — same as ShowOffCube
    const s = this.cubeState;
    if (faceName === 'U') {
      if (clockwise) {
        const tmp = [s.F[0][0], s.F[0][1], s.F[0][2]];
        [s.F[0][0], s.F[0][1], s.F[0][2]] = [s.R[0][0], s.R[0][1], s.R[0][2]];
        [s.R[0][0], s.R[0][1], s.R[0][2]] = [s.B[0][0], s.B[0][1], s.B[0][2]];
        [s.B[0][0], s.B[0][1], s.B[0][2]] = [s.L[0][0], s.L[0][1], s.L[0][2]];
        [s.L[0][0], s.L[0][1], s.L[0][2]] = tmp;
      } else {
        const tmp = [s.F[0][0], s.F[0][1], s.F[0][2]];
        [s.F[0][0], s.F[0][1], s.F[0][2]] = [s.L[0][0], s.L[0][1], s.L[0][2]];
        [s.L[0][0], s.L[0][1], s.L[0][2]] = [s.B[0][0], s.B[0][1], s.B[0][2]];
        [s.B[0][0], s.B[0][1], s.B[0][2]] = [s.R[0][0], s.R[0][1], s.R[0][2]];
        [s.R[0][0], s.R[0][1], s.R[0][2]] = tmp;
      }
    } else if (faceName === 'D') {
      if (clockwise) {
        const tmp = [s.F[2][0], s.F[2][1], s.F[2][2]];
        [s.F[2][0], s.F[2][1], s.F[2][2]] = [s.L[2][0], s.L[2][1], s.L[2][2]];
        [s.L[2][0], s.L[2][1], s.L[2][2]] = [s.B[2][0], s.B[2][1], s.B[2][2]];
        [s.B[2][0], s.B[2][1], s.B[2][2]] = [s.R[2][0], s.R[2][1], s.R[2][2]];
        [s.R[2][0], s.R[2][1], s.R[2][2]] = tmp;
      } else {
        const tmp = [s.F[2][0], s.F[2][1], s.F[2][2]];
        [s.F[2][0], s.F[2][1], s.F[2][2]] = [s.R[2][0], s.R[2][1], s.R[2][2]];
        [s.R[2][0], s.R[2][1], s.R[2][2]] = [s.B[2][0], s.B[2][1], s.B[2][2]];
        [s.B[2][0], s.B[2][1], s.B[2][2]] = [s.L[2][0], s.L[2][1], s.L[2][2]];
        [s.L[2][0], s.L[2][1], s.L[2][2]] = tmp;
      }
    } else if (faceName === 'F') {
      if (clockwise) {
        const tmp = [s.U[2][0], s.U[2][1], s.U[2][2]];
        [s.U[2][0], s.U[2][1], s.U[2][2]] = [s.L[2][2], s.L[1][2], s.L[0][2]];
        [s.L[0][2], s.L[1][2], s.L[2][2]] = [s.D[0][0], s.D[0][1], s.D[0][2]];
        [s.D[0][0], s.D[0][1], s.D[0][2]] = [s.R[2][0], s.R[1][0], s.R[0][0]];
        [s.R[0][0], s.R[1][0], s.R[2][0]] = tmp;
      } else {
        const tmp = [s.U[2][0], s.U[2][1], s.U[2][2]];
        [s.U[2][0], s.U[2][1], s.U[2][2]] = [s.R[0][0], s.R[1][0], s.R[2][0]];
        [s.R[0][0], s.R[1][0], s.R[2][0]] = [s.D[0][2], s.D[0][1], s.D[0][0]];
        [s.D[0][0], s.D[0][1], s.D[0][2]] = [s.L[0][2], s.L[1][2], s.L[2][2]];
        [s.L[0][2], s.L[1][2], s.L[2][2]] = [tmp[2], tmp[1], tmp[0]];
      }
    } else if (faceName === 'B') {
      if (clockwise) {
        const tmp = [s.U[0][0], s.U[0][1], s.U[0][2]];
        [s.U[0][0], s.U[0][1], s.U[0][2]] = [s.R[0][2], s.R[1][2], s.R[2][2]];
        [s.R[0][2], s.R[1][2], s.R[2][2]] = [s.D[2][2], s.D[2][1], s.D[2][0]];
        [s.D[2][0], s.D[2][1], s.D[2][2]] = [s.L[0][0], s.L[1][0], s.L[2][0]];
        [s.L[0][0], s.L[1][0], s.L[2][0]] = [tmp[2], tmp[1], tmp[0]];
      } else {
        const tmp = [s.U[0][0], s.U[0][1], s.U[0][2]];
        [s.U[0][0], s.U[0][1], s.U[0][2]] = [s.L[2][0], s.L[1][0], s.L[0][0]];
        [s.L[0][0], s.L[1][0], s.L[2][0]] = [s.D[2][2], s.D[2][1], s.D[2][0]];
        [s.D[2][0], s.D[2][1], s.D[2][2]] = [s.R[2][2], s.R[1][2], s.R[0][2]];
        [s.R[0][2], s.R[1][2], s.R[2][2]] = tmp;
      }
    } else if (faceName === 'R') {
      if (clockwise) {
        const tmp = [s.U[0][2], s.U[1][2], s.U[2][2]];
        [s.U[0][2], s.U[1][2], s.U[2][2]] = [s.F[0][2], s.F[1][2], s.F[2][2]];
        [s.F[0][2], s.F[1][2], s.F[2][2]] = [s.D[0][2], s.D[1][2], s.D[2][2]];
        [s.D[0][2], s.D[1][2], s.D[2][2]] = [s.B[2][0], s.B[1][0], s.B[0][0]];
        [s.B[0][0], s.B[1][0], s.B[2][0]] = [tmp[2], tmp[1], tmp[0]];
      } else {
        const tmp = [s.U[0][2], s.U[1][2], s.U[2][2]];
        [s.U[0][2], s.U[1][2], s.U[2][2]] = [s.B[2][0], s.B[1][0], s.B[0][0]];
        [s.B[0][0], s.B[1][0], s.B[2][0]] = [s.D[2][2], s.D[1][2], s.D[0][2]];
        [s.D[0][2], s.D[1][2], s.D[2][2]] = [s.F[0][2], s.F[1][2], s.F[2][2]];
        [s.F[0][2], s.F[1][2], s.F[2][2]] = tmp;
      }
    } else if (faceName === 'L') {
      if (clockwise) {
        const tmp = [s.U[0][0], s.U[1][0], s.U[2][0]];
        [s.U[0][0], s.U[1][0], s.U[2][0]] = [s.B[2][2], s.B[1][2], s.B[0][2]];
        [s.B[0][2], s.B[1][2], s.B[2][2]] = [s.D[2][0], s.D[1][0], s.D[0][0]];
        [s.D[0][0], s.D[1][0], s.D[2][0]] = [s.F[0][0], s.F[1][0], s.F[2][0]];
        [s.F[0][0], s.F[1][0], s.F[2][0]] = tmp;
      } else {
        const tmp = [s.U[0][0], s.U[1][0], s.U[2][0]];
        [s.U[0][0], s.U[1][0], s.U[2][0]] = [s.F[0][0], s.F[1][0], s.F[2][0]];
        [s.F[0][0], s.F[1][0], s.F[2][0]] = [s.D[0][0], s.D[1][0], s.D[2][0]];
        [s.D[0][0], s.D[1][0], s.D[2][0]] = [s.B[2][2], s.B[1][2], s.B[0][2]];
        [s.B[0][2], s.B[1][2], s.B[2][2]] = [tmp[2], tmp[1], tmp[0]];
      }
    }
  }

  // Core crawl animation — two opposing face rotations + translation
  crawlMove(direction, duration) {
    return new Promise((resolve, reject) => {
      if (this._activeCrawl) { reject(new Error('crawl in progress')); return; }
      const map = CRAWL_MAP[direction];
      if (!map) { reject(new Error('bad direction')); return; }

      // Update logical cube state for both faces
      this.rotateCubeState(map.face1, map.cw1);
      this.rotateCubeState(map.face2, map.cw2);
      this.moveSequence.push(map.face1 + (map.cw1 ? '' : "'"), map.face2 + (map.cw2 ? '' : "'"));
      this.crawlerHistory.push(direction);

      // Get layer cubies for both faces
      const f1 = FACES[map.face1];
      const f2 = FACES[map.face2];
      const layer1 = this.getCubiesOnLayer(f1.axis, f1.layer);
      const layer2 = this.getCubiesOnLayer(f2.axis, f2.layer);

      // Create pivots
      const pivot1 = new THREE.Group();
      const pivot2 = new THREE.Group();
      this.group.add(pivot1);
      this.group.add(pivot2);

      for (const mesh of layer1) { this.group.remove(mesh); pivot1.add(mesh); }
      for (const mesh of layer2) { this.group.remove(mesh); pivot2.add(mesh); }

      const angle1 = (map.cw1 ? -1 : 1) * f1.dir * (Math.PI / 2);
      const angle2 = (map.cw2 ? -1 : 1) * f2.dir * (Math.PI / 2);

      // Translation target
      const tileStep = CRAWL_TILE_SIZE + TILE_GAP;
      const startPos = this.group.position.clone();
      const endPos = startPos.clone();
      endPos.x += map.dx * tileStep;
      endPos.z += map.dz * tileStep;

      this._activeCrawl = {
        pivot1, pivot2, layer1, layer2,
        axis1: f1.axis, angle1, axis2: f2.axis, angle2,
        startPos, endPos,
        startTime: performance.now(),
        duration: Math.max(duration, 1),
        resolve,
      };
    });
  }

  // Lazy susan — spin top 2 layers, bottom stays
  spinMove(clockwise, duration) {
    return new Promise((resolve, reject) => {
      if (this._activeCrawl) { reject(new Error('crawl in progress')); return; }

      // Logical state: rotating U layer CW means D-perspective stays, U+middle spin
      // We rotate U face state, and also rotate the middle-layer edges via an E-slice equivalent
      // Simpler: U + equator = whole-cube Y minus D. So apply U rotation to state.
      this.rotateCubeState('U', clockwise);
      // Also rotate the equator (middle) slice — equivalent to D' when combined with U
      // The equator follows U direction: rotate adjacent edges of middle row
      const s = this.cubeState;
      if (clockwise) {
        const tmp = [s.F[1][0], s.F[1][1], s.F[1][2]];
        [s.F[1][0], s.F[1][1], s.F[1][2]] = [s.R[1][0], s.R[1][1], s.R[1][2]];
        [s.R[1][0], s.R[1][1], s.R[1][2]] = [s.B[1][0], s.B[1][1], s.B[1][2]];
        [s.B[1][0], s.B[1][1], s.B[1][2]] = [s.L[1][0], s.L[1][1], s.L[1][2]];
        [s.L[1][0], s.L[1][1], s.L[1][2]] = tmp;
      } else {
        const tmp = [s.F[1][0], s.F[1][1], s.F[1][2]];
        [s.F[1][0], s.F[1][1], s.F[1][2]] = [s.L[1][0], s.L[1][1], s.L[1][2]];
        [s.L[1][0], s.L[1][1], s.L[1][2]] = [s.B[1][0], s.B[1][1], s.B[1][2]];
        [s.B[1][0], s.B[1][1], s.B[1][2]] = [s.R[1][0], s.R[1][1], s.R[1][2]];
        [s.R[1][0], s.R[1][1], s.R[1][2]] = tmp;
      }

      this.moveSequence.push('spin' + (clockwise ? '' : "'"));
      this.crawlerHistory.push('spin2' + (clockwise ? '' : "'"));

      // Visual: select cubies with y >= 0 (top + middle = 18 cubies)
      const upperCubies = this.cubies.filter(m => Math.round(m.userData.pos.y) >= 0);
      const pivot = new THREE.Group();
      this.group.add(pivot);
      for (const mesh of upperCubies) { this.group.remove(mesh); pivot.add(mesh); }

      // U CW visually = -Y rotation
      const angle = clockwise ? -(Math.PI / 2) : (Math.PI / 2);

      this._activeCrawl = {
        pivot1: pivot, pivot2: null, layer1: upperCubies, layer2: [],
        axis1: 'y', angle1: angle, axis2: null, angle2: 0,
        startPos: this.group.position.clone(),
        endPos: this.group.position.clone(), // no translation
        startTime: performance.now(),
        duration: Math.max(duration, 1),
        resolve,
      };
    });
  }

  // Spin top layer only — U face rotation, no equator
  spin1Move(clockwise, duration) {
    return new Promise((resolve, reject) => {
      if (this._activeCrawl) { reject(new Error('crawl in progress')); return; }

      // Logical state: only rotate U face
      this.rotateCubeState('U', clockwise);

      this.moveSequence.push('spin1' + (clockwise ? '' : "'"));
      this.crawlerHistory.push('spin1' + (clockwise ? '' : "'"));

      // Visual: select cubies with y === 1 (top layer = 9 cubies)
      const topCubies = this.cubies.filter(m => Math.round(m.userData.pos.y) === 1);
      const pivot = new THREE.Group();
      this.group.add(pivot);
      for (const mesh of topCubies) { this.group.remove(mesh); pivot.add(mesh); }

      const angle = clockwise ? -(Math.PI / 2) : (Math.PI / 2);

      this._activeCrawl = {
        pivot1: pivot, pivot2: null, layer1: topCubies, layer2: [],
        axis1: 'y', angle1: angle, axis2: null, angle2: 0,
        startPos: this.group.position.clone(),
        endPos: this.group.position.clone(), // no translation
        startTime: performance.now(),
        duration: Math.max(duration, 1),
        resolve,
      };
    });
  }

  updateAnimation(now) {
    const c = this._activeCrawl;
    if (!c) return;

    const t = Math.min((now - c.startTime) / c.duration, 1);
    const eased = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

    // Rotate pivots
    if (c.pivot1) {
      if (c.axis1 === 'x') c.pivot1.rotation.x = c.angle1 * eased;
      else if (c.axis1 === 'y') c.pivot1.rotation.y = c.angle1 * eased;
      else if (c.axis1 === 'z') c.pivot1.rotation.z = c.angle1 * eased;
    }
    if (c.pivot2) {
      if (c.axis2 === 'x') c.pivot2.rotation.x = c.angle2 * eased;
      else if (c.axis2 === 'y') c.pivot2.rotation.y = c.angle2 * eased;
      else if (c.axis2 === 'z') c.pivot2.rotation.z = c.angle2 * eased;
    }

    // Translate group
    this.group.position.lerpVectors(c.startPos, c.endPos, eased);

    if (t >= 1) this._finishCrawl();
  }

  _finishCrawl() {
    const c = this._activeCrawl;
    if (!c) return;
    this._activeCrawl = null;

    // Reparent cubies from pivot(s) back to group
    const pivots = [c.pivot1, c.pivot2].filter(Boolean);
    const layers = [c.layer1, c.layer2];
    for (let i = 0; i < pivots.length; i++) {
      const pivot = pivots[i];
      pivot.updateMatrixWorld(true);
      for (const mesh of layers[i]) {
        mesh.applyMatrix4(pivot.matrixWorld);
        mesh.position.sub(this.group.position);
        pivot.remove(mesh);
        this.group.add(mesh);
        // Snap to grid
        mesh.userData.pos = {
          x: Math.round(mesh.position.x / STEP),
          y: Math.round(mesh.position.y / STEP),
          z: Math.round(mesh.position.z / STEP),
        };
        mesh.position.set(
          mesh.userData.pos.x * STEP,
          mesh.userData.pos.y * STEP,
          mesh.userData.pos.z * STEP
        );
      }
      this.group.remove(pivot);
    }

    // Snap group position to exact grid position
    this.group.position.copy(c.endPos);

    c.resolve();
  }
}

// ─── CRAWLER MODE ────────────────────────────────────────────

let crawlerMode = false;
let crawlerCube = null;
let crawlerBusy = false;
let crawlerDemoRunning = false;
let crawlerSolveRunning = false;
let crawlerScrambleMoves = [];
let crawlerFloorGroup = null;
let crawlerTiles = [];
let crawlerGridX = 0;
let crawlerGridZ = 0;
let crawlerVisited = 0;
let savedFogDensity = 0.02;
let crawlerMoveCount = 0;
let crawlerStepSolving = false;
let crawlerSolution = { moves: [], index: 0 };

function gridToWorld(gx, gz) {
  const tileStep = CRAWL_TILE_SIZE + TILE_GAP;
  const totalSpan = crawlGrid * tileStep - TILE_GAP;
  const halfSpan = totalSpan / 2;
  return new THREE.Vector3(
    gx * tileStep - halfSpan + CRAWL_TILE_SIZE / 2,
    0,
    gz * tileStep - halfSpan + CRAWL_TILE_SIZE / 2
  );
}

function buildCrawlerFloor() {
  if (crawlerFloorGroup) {
    scene.remove(crawlerFloorGroup);
    crawlerFloorGroup = null;
  }
  crawlerFloorGroup = new THREE.Group();
  crawlerTiles = [];
  const tileGeo = new THREE.BoxGeometry(CRAWL_TILE_SIZE, 0.1, CRAWL_TILE_SIZE);
  const floorY = -(STEP + CUBIE_SIZE / 2) - 0.05;
  const tileStep = CRAWL_TILE_SIZE + TILE_GAP;
  const totalSpan = crawlGrid * tileStep - TILE_GAP;
  const halfSpan = totalSpan / 2;

  for (let row = 0; row < crawlGrid; row++) {
    crawlerTiles[row] = [];
    for (let col = 0; col < crawlGrid; col++) {
      const isLight = (row + col) % 2 === 0;
      const color = isLight ? 0xDEB887 : 0x8B4513;
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.8, metalness: 0.1, transparent: true, opacity: 0.6 });
      const tile = new THREE.Mesh(tileGeo, mat);
      tile.position.set(
        col * tileStep - halfSpan + CRAWL_TILE_SIZE / 2,
        floorY,
        row * tileStep - halfSpan + CRAWL_TILE_SIZE / 2
      );
      tile.receiveShadow = true;
      crawlerFloorGroup.add(tile);
      crawlerTiles[row][col] = tile;
    }
  }
  scene.add(crawlerFloorGroup);
}

function markTileVisited(gx, gz) {
  if (gz >= 0 && gz < crawlGrid && gx >= 0 && gx < crawlGrid) {
    const tile = crawlerTiles[gz][gx];
    const isLight = (gz + gx) % 2 === 0;
    tile.material.color.setHex(isLight ? 0xFFD700 : 0xDAA520);
    tile.material.opacity = 0.75;
  }
}

function enterCrawlerMode() {
  if (crawlerMode || showOffMode) return;
  crawlerMode = true;

  // Hide normal UI
  document.getElementById('bottom-bar').style.display = 'none';
  document.getElementById('info-overlay').style.display = 'none';
  cubieGroup.visible = false;
  faceLabelGroup.visible = false;
  document.getElementById('btn-showoff').style.display = 'none';
  document.getElementById('btn-crawler').style.display = 'none';
  document.getElementById('btn-toggle-face-controls').style.display = 'none';

  // Show crawler bar
  document.getElementById('crawler-bar').classList.add('visible');

  // Reduce fog so far tiles are visible
  savedFogDensity = scene.fog.density;
  scene.fog.density = 0.005;

  // Build floor and cube
  buildCrawlerFloor();
  crawlerGridX = 0;
  crawlerGridZ = 0;
  crawlerVisited = 1;
  const pos = gridToWorld(0, 0);
  crawlerCube = new CrawlerCube(pos);
  markTileVisited(0, 0);

  // Position camera to see full floor
  const tileStep = CRAWL_TILE_SIZE + TILE_GAP;
  const totalSpan = crawlGrid * tileStep;
  const fovRad = (camera.fov * Math.PI) / 180;
  const dist = Math.max((totalSpan / 2) / Math.tan(fovRad / 2) * 1.2, 10);
  animateCameraToPosition(new THREE.Vector3(dist * 0.6, dist * 0.7, dist * 0.6), 600);
  orbitControls.minDistance = 5;
  orbitControls.maxDistance = dist * 2;

  updateCrawlerStatus('Arrow keys to steer · Space=spin2 · Tab=spin1');
  debugLog('Entered crawler mode');
}

function exitCrawlerMode() {
  if (!crawlerMode) return;

  crawlerDemoRunning = false;
  crawlerSolveRunning = false;
  crawlerScrambleMoves = [];
  exitCrawlerStepMode();
  crawlerMoveCount = 0;

  // Dispose cube
  if (crawlerCube) { crawlerCube.dispose(); crawlerCube = null; }

  // Dispose floor
  if (crawlerFloorGroup) {
    crawlerFloorGroup.traverse(child => {
      if (child.isMesh) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    scene.remove(crawlerFloorGroup);
    crawlerFloorGroup = null;
  }
  crawlerTiles = [];

  crawlerMode = false;

  // Restore fog
  scene.fog.density = savedFogDensity;

  // Restore UI
  document.getElementById('bottom-bar').style.display = '';
  document.getElementById('info-overlay').style.display = '';
  cubieGroup.visible = true;
  faceLabelGroup.visible = true;
  document.getElementById('btn-showoff').style.display = '';
  document.getElementById('btn-crawler').style.display = '';
  document.getElementById('btn-toggle-face-controls').style.display = '';
  document.getElementById('crawler-bar').classList.remove('visible');

  // Reset camera
  animateCameraToPosition(new THREE.Vector3(6, 5, 6), 500);
  orbitControls.minDistance = 4;
  orbitControls.maxDistance = 15;

  debugLog('Exited crawler mode');
}

function generateSnakePath() {
  const path = [];
  for (let row = 0; row < crawlGrid; row++) {
    if (row > 0) path.push('+z'); // move down to next row
    const goRight = (row % 2 === 0);
    for (let i = 0; i < crawlGrid - 1; i++) {
      path.push(goRight ? '+x' : '-x');
    }
  }
  return path;
}

async function runCrawlerDemo() {
  if (crawlerDemoRunning) return;
  crawlerDemoRunning = true;

  // Reset to starting position
  resetCrawler();

  const speed = parseInt(document.getElementById('cr-speed').value) || 350;
  const path = generateSnakePath();
  let tileCount = 1; // already on tile 0,0

  for (let i = 0; i < path.length; i++) {
    if (!crawlerDemoRunning) break;
    const dir = path[i];
    const map = CRAWL_MAP[dir];
    crawlerGridX += map.dx;
    crawlerGridZ += map.dz;

    crawlerBusy = true;
    await crawlerCube.crawlMove(dir, speed);
    markTileVisited(crawlerGridX, crawlerGridZ);
    tileCount++;
    crawlerBusy = false;
    updateCrawlerStatus(`Demo: tile ${tileCount}/${crawlGrid * crawlGrid}`);
  }

  crawlerDemoRunning = false;
  if (crawlerMode) {
    updateCrawlerStatus('Demo complete! Arrow keys to steer.');
  }
}

function resetCrawler() {
  crawlerDemoRunning = false;
  crawlerSolveRunning = false;
  crawlerScrambleMoves = [];
  crawlerBusy = false;
  crawlerMoveCount = 0;
  updateCrawlerMoveCount();
  exitCrawlerStepMode();
  if (crawlerCube) { crawlerCube.dispose(); crawlerCube = null; }
  buildCrawlerFloor();
  crawlerGridX = 0;
  crawlerGridZ = 0;
  crawlerVisited = 1;
  const pos = gridToWorld(0, 0);
  crawlerCube = new CrawlerCube(pos);
  markTileVisited(0, 0);
  const solveBtn = document.getElementById('cr-solve');
  if (solveBtn) solveBtn.disabled = true;
  updateCrawlerStatus('Arrow keys to steer · Space=spin2 · Tab=spin1');
}

function resetCrawlerToCenter() {
  crawlerDemoRunning = false;
  crawlerSolveRunning = false;
  crawlerScrambleMoves = [];
  crawlerBusy = false;
  crawlerMoveCount = 0;
  updateCrawlerMoveCount();
  if (crawlerCube) { crawlerCube.dispose(); crawlerCube = null; }
  buildCrawlerFloor();
  const cx = Math.floor(crawlGrid / 2);
  const cz = Math.floor(crawlGrid / 2);
  crawlerGridX = cx;
  crawlerGridZ = cz;
  crawlerVisited = 1;
  const pos = gridToWorld(cx, cz);
  crawlerCube = new CrawlerCube(pos);
  markTileVisited(cx, cz);
}

async function executeCrawlerMove(move, speed) {
  const map = CRAWL_MAP[move];
  if (map) {
    // Directional move
    crawlerGridX += map.dx;
    crawlerGridZ += map.dz;
    await crawlerCube.crawlMove(move, speed);
    markTileVisited(crawlerGridX, crawlerGridZ);
  } else if (move === 'spin2' || move === "spin2'") {
    await crawlerCube.spinMove(move === 'spin2', speed);
  } else if (move === 'spin1' || move === "spin1'") {
    await crawlerCube.spin1Move(move === 'spin1', speed);
  }
}

async function runCrawlerScramble() {
  if (crawlerBusy || crawlerDemoRunning || crawlerSolveRunning) return;

  // Reset to center of grid for maximum room
  resetCrawlerToCenter();
  updateCrawlerStatus('Scrambling...');

  const cx = Math.floor(crawlGrid / 2);
  const numMoves = Math.max(8, Math.round(crawlGrid * crawlGrid * 0.4));
  const scramble = generateCrawlerScramble(numMoves, cx, cx);
  crawlerScrambleMoves = [];

  const speed = Math.min(parseInt(document.getElementById('cr-speed').value) || 350, 150);
  crawlerBusy = true;

  for (let i = 0; i < scramble.length; i++) {
    const move = scramble[i];
    await executeCrawlerMove(move, speed);
    crawlerScrambleMoves.push(move);
    updateCrawlerStatus(`Scrambling: ${i + 1}/${scramble.length}`);
  }

  crawlerBusy = false;
  const solveBtn = document.getElementById('cr-solve');
  if (solveBtn) solveBtn.disabled = false;
  updateCrawlerStatus(`Scrambled (${scramble.length} moves) · Solve or steer manually`);
}

async function runCrawlerSolve() {
  if (crawlerBusy || crawlerDemoRunning || crawlerSolveRunning || crawlerStepSolving) return;
  if (!crawlerCube) return;

  // Check if already solved
  if (crawlerCube.isSolved()) {
    updateCrawlerStatus('Already solved!');
    return;
  }

  // Build solution from full history (scramble + any manual moves)
  const history = crawlerCube.crawlerHistory.slice();
  if (history.length === 0) {
    updateCrawlerStatus('No moves to reverse!');
    return;
  }

  const solution = generateCrawlerSolution(history);
  if (solution.length === 0) {
    updateCrawlerStatus('Already solved!');
    return;
  }

  // Step mode — enter step-through instead of auto-playing
  const speedVal = document.getElementById('cr-speed').value;
  if (speedVal === 'step') {
    enterCrawlerStepMode(solution);
    return;
  }

  await runCrawlerSolveAuto(solution, 0);
}

async function runCrawlerSolveAuto(solution, startIndex) {
  crawlerSolveRunning = true;
  crawlerBusy = true;
  const solveBtn = document.getElementById('cr-solve');
  if (solveBtn) solveBtn.disabled = true;

  const speed = parseInt(document.getElementById('cr-speed').value) || 350;

  for (let i = startIndex; i < solution.length; i++) {
    if (!crawlerSolveRunning || !crawlerMode) break;
    const move = solution[i];

    // Check grid bounds for directional moves
    const map = CRAWL_MAP[move];
    if (map) {
      const nx = crawlerGridX + map.dx;
      const nz = crawlerGridZ + map.dz;
      if (nx < 0 || nx >= crawlGrid || nz < 0 || nz >= crawlGrid) {
        updateCrawlerStatus('Solve hit grid edge — stopping');
        break;
      }
    }

    await executeCrawlerMove(move, speed);
    crawlerMoveCount++;
    updateCrawlerMoveCount();
    updateCrawlerStatus(`Solving: ${i + 1}/${solution.length}`);
  }

  crawlerSolveRunning = false;
  crawlerBusy = false;

  if (crawlerCube && crawlerCube.isSolved()) {
    updateCrawlerStatus('Solved! · Scramble again or steer');
  } else {
    updateCrawlerStatus('Solve complete · Arrow keys to steer');
  }
}

function updateCrawlerStatus(msg) {
  document.getElementById('crawler-status').textContent = msg;
}

function updateCrawlerMoveCount() {
  const el = document.getElementById('crawler-move-count');
  if (el) el.textContent = `Moves: ${crawlerMoveCount}`;
}

function setCrawlerGridSize(size) {
  if (crawlerBusy || crawlerDemoRunning || crawlerSolveRunning || crawlerStepSolving) return;
  crawlGrid = size;
  // Update active state on grid buttons
  document.querySelectorAll('[data-crawl-grid]').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.crawlGrid) === size);
  });
  resetCrawler();
  // Reposition camera to fit new grid
  const tileStep = CRAWL_TILE_SIZE + TILE_GAP;
  const totalSpan = crawlGrid * tileStep;
  const fovRad = (camera.fov * Math.PI) / 180;
  const dist = Math.max((totalSpan / 2) / Math.tan(fovRad / 2) * 1.2, 10);
  animateCameraToPosition(new THREE.Vector3(dist * 0.6, dist * 0.7, dist * 0.6), 600);
  orbitControls.maxDistance = dist * 2;
}

// ─── CRAWLER STEP MODE ──────────────────────────────────────

function enterCrawlerStepMode(solution) {
  crawlerStepSolving = true;
  crawlerSolution = { moves: solution, index: 0 };
  document.getElementById('cr-step-back').style.display = '';
  document.getElementById('cr-step-fwd').style.display = '';
  document.getElementById('cr-solve').disabled = true;
  updateCrawlerStatus(`Step 0 / ${solution.length} — use ▶▶ or arrow keys`);
}

function exitCrawlerStepMode() {
  crawlerStepSolving = false;
  crawlerSolution = { moves: [], index: 0 };
  document.getElementById('cr-step-back').style.display = 'none';
  document.getElementById('cr-step-fwd').style.display = 'none';
}

async function crawlerStepForward() {
  if (!crawlerStepSolving || crawlerBusy) return;
  if (crawlerSolution.index >= crawlerSolution.moves.length) {
    updateCrawlerStatus('Solve complete!');
    return;
  }
  const move = crawlerSolution.moves[crawlerSolution.index];
  // Check grid bounds for directional moves
  const map = CRAWL_MAP[move];
  if (map) {
    const nx = crawlerGridX + map.dx;
    const nz = crawlerGridZ + map.dz;
    if (nx < 0 || nx >= crawlGrid || nz < 0 || nz >= crawlGrid) {
      updateCrawlerStatus('Step hit grid edge — cannot proceed');
      return;
    }
  }
  const speed = 350; // fixed speed for step mode
  crawlerBusy = true;
  await executeCrawlerMove(move, speed);
  crawlerMoveCount++;
  updateCrawlerMoveCount();
  crawlerBusy = false;
  crawlerSolution.index++;
  updateCrawlerStatus(`Step ${crawlerSolution.index} / ${crawlerSolution.moves.length}`);
  if (crawlerSolution.index >= crawlerSolution.moves.length) {
    exitCrawlerStepMode();
    if (crawlerCube && crawlerCube.isSolved()) {
      updateCrawlerStatus('Solved! · Scramble again or steer');
    } else {
      updateCrawlerStatus('Solve complete · Arrow keys to steer');
    }
  }
}

async function crawlerStepBack() {
  if (!crawlerStepSolving || crawlerBusy) return;
  if (crawlerSolution.index <= 0) {
    updateCrawlerStatus('Already at start of solution');
    return;
  }
  crawlerSolution.index--;
  const move = crawlerSolution.moves[crawlerSolution.index];
  const inverse = CRAWLER_INVERSE[move];
  // Check grid bounds for inverse move
  const map = CRAWL_MAP[inverse];
  if (map) {
    const nx = crawlerGridX + map.dx;
    const nz = crawlerGridZ + map.dz;
    if (nx < 0 || nx >= crawlGrid || nz < 0 || nz >= crawlGrid) {
      crawlerSolution.index++; // revert
      updateCrawlerStatus('Step back hit grid edge');
      return;
    }
  }
  const speed = 350;
  crawlerBusy = true;
  await executeCrawlerMove(inverse, speed);
  crawlerMoveCount++;
  updateCrawlerMoveCount();
  crawlerBusy = false;
  updateCrawlerStatus(`Step ${crawlerSolution.index} / ${crawlerSolution.moves.length}`);
}

// ─── SHOW OFF GRID & CAMERA ──────────────────────────────────

const GRID_CELL = 3 * STEP + 1.5;
let currentGridSize = 3;

function createShowOffGrid(n) {
  clearShowOffGrid();
  currentGridSize = n;
  debugLog(`Creating ${n}x${n} grid (${n*n} cubes)`);

  document.querySelectorAll('.grid-btn').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.grid) === n);
  });

  const offset = (n - 1) * GRID_CELL / 2;

  for (let row = 0; row < n; row++) {
    for (let col = 0; col < n; col++) {
      const x = col * GRID_CELL - offset;
      const z = row * GRID_CELL - offset;
      const cube = new ShowOffCube(new THREE.Vector3(x, 0, z));
      showOffCubes.push(cube);
    }
  }

  debugLog(`Grid created: ${showOffCubes.length} cubes, ${showOffCubes.length * 27} cubies`);
  zoomCameraToFitGrid(n);
}

function clearShowOffGrid() {
  for (const cube of showOffCubes) cube.dispose();
  showOffCubes.length = 0;
}

function zoomCameraToFitGrid(n) {
  const fovRad = (camera.fov * Math.PI) / 180;
  const gridSpan = n * GRID_CELL;
  const dist = Math.max((gridSpan / 2) / Math.tan(fovRad / 2) * 1.4, 6);
  const targetPos = new THREE.Vector3(dist * 0.5, dist * 0.7, dist * 0.5);
  orbitControls.maxDistance = dist * 2;
  animateCameraToPosition(targetPos, 600);
}

// Wire grid preset buttons
document.querySelectorAll('.grid-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    if (showOffBusy) return;
    createShowOffGrid(parseInt(btn.dataset.grid));
  });
});

// ─── CONFETTI SYSTEM ─────────────────────────────────────────

const CONFETTI_COLORS = [0xc41e3a, 0xff5800, 0xffffff, 0xffd500, 0x009b48, 0x0045ad];

class ConfettiSystem {
  constructor() {
    this.particles = [];
    this.geo = new THREE.BoxGeometry(0.08, 0.08, 0.02);
  }

  fireFromAllCubes() {
    for (const soCube of showOffCubes) {
      this.spawnFromCube(soCube);
    }
  }

  spawnFromCube(soCube) {
    const cubeWorldPos = new THREE.Vector3();
    soCube.group.getWorldPosition(cubeWorldPos);

    // Spawn particles from each of the 6 face centers
    const normals = [
      new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
      new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
      new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1),
    ];

    for (const normal of normals) {
      const faceCenter = cubeWorldPos.clone().add(normal.clone().multiplyScalar(STEP * 1.5));
      // 6 particles per face (36 per cube — keeps mobile perf reasonable)
      for (let i = 0; i < 6; i++) {
        const color = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
        const mesh = new THREE.Mesh(this.geo, mat);

        mesh.position.copy(faceCenter);
        // Random rotation for variety
        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

        // Velocity: outward from face + random spread + upward bias
        const vel = new THREE.Vector3(
          normal.x * (2 + Math.random() * 3) + (Math.random() - 0.5) * 3,
          normal.y * (2 + Math.random() * 3) + 2 + Math.random() * 4,
          normal.z * (2 + Math.random() * 3) + (Math.random() - 0.5) * 3,
        );

        scene.add(mesh);
        this.particles.push({
          mesh,
          mat,
          vel,
          spin: new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
          ),
          life: 1.0,
          decay: 0.25 + Math.random() * 0.15, // dies in ~3-4 sec
        });
      }
    }
  }

  update(dt) {
    const gravity = -12;
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.vel.y += gravity * dt;
      p.mesh.position.addScaledVector(p.vel, dt);
      p.mesh.rotation.x += p.spin.x * dt;
      p.mesh.rotation.y += p.spin.y * dt;
      p.mesh.rotation.z += p.spin.z * dt;

      // Air resistance
      p.vel.multiplyScalar(1 - 1.5 * dt);

      p.life -= p.decay * dt;
      p.mat.opacity = Math.max(0, p.life);

      if (p.life <= 0) {
        scene.remove(p.mesh);
        p.mat.dispose();
        this.particles.splice(i, 1);
      }
    }
  }

  clear() {
    for (const p of this.particles) {
      scene.remove(p.mesh);
      p.mat.dispose();
    }
    this.particles.length = 0;
  }

  get active() {
    return this.particles.length > 0;
  }
}

const confettiSystem = new ConfettiSystem();

// ─── SHOW OFF: SCRAMBLE ALL & SOLVE ALL ──────────────────────

function getShowOffSpeed() {
  return parseInt(document.getElementById('so-speed').value, 10);
}

function setShowOffBusy(busy) {
  showOffBusy = busy;
  document.getElementById('so-scramble').disabled = busy;
  document.getElementById('so-solve').disabled = busy;
  document.getElementById('so-exit').disabled = busy;
  document.querySelectorAll('.grid-btn').forEach(b => b.disabled = busy);
}

async function showOffScramble() {
  if (showOffBusy || showOffCubes.length === 0) return;
  setShowOffBusy(true);
  debugLog(`Scramble: ${showOffCubes.length} cubes, speed=${getShowOffSpeed()}`);

  const speed = getShowOffSpeed();
  const scrambleLength = 20;

  const allScrambles = showOffCubes.map(() => generateScramble(scrambleLength));
  const maxLen = Math.max(...allScrambles.map(s => s.length));
  debugLog(`Scramble: maxLen=${maxLen} moves`);

  for (let i = 0; i < maxLen; i++) {
    const promises = [];
    for (let c = 0; c < showOffCubes.length; c++) {
      if (i < allScrambles[c].length) {
        const move = allScrambles[c][i];
        promises.push(showOffCubes[c].doMove(move.face, move.clockwise, speed));
      }
    }
    await Promise.all(promises);
    // Yield to browser between steps
    await new Promise(r => setTimeout(r, 0));
  }

  debugLog('Scramble complete');
  setShowOffBusy(false);
}

async function showOffSolve() {
  debugLog('--- showOffSolve START ---');
  if (showOffBusy || showOffCubes.length === 0) {
    debugLog(`showOffSolve: blocked (busy=${showOffBusy}, cubes=${showOffCubes.length})`);
    return;
  }

  // Check if worker solver is available
  debugLog(`Solver status: worker=${solverWorkerReady}, main=${solverReady}`);
  if (!solverWorkerReady) {
    if (!solverReady) {
      showSolverStatus('Solver still loading...');
      debugLog('Solve: NEITHER solver ready — aborting');
      return;
    }
    debugLog('Solve: worker NOT ready, using main thread (will block)');
  }

  const unsolved = showOffCubes.filter(c => !c.isSolved());
  if (unsolved.length === 0) {
    showSolverStatus('All cubes already solved!');
    debugLog('Solve: all already solved');
    return;
  }

  setShowOffBusy(true);
  const useWorker = solverWorkerReady;
  debugLog(`Solve: ${showOffCubes.length} cubes, ${unsolved.length} unsolved, worker=${useWorker}`);

  const total = showOffCubes.length;
  const statusEl = document.getElementById('solver-status');
  const allSolutions = [];

  // Yield to let status text paint
  await new Promise(r => setTimeout(r, 10));

  for (let i = 0; i < total; i++) {
    const soCube = showOffCubes[i];
    if (soCube.isSolved()) {
      allSolutions.push([]);
      debugLog(`Cube ${i}: already solved, skip`);
      continue;
    }

    statusEl.textContent = `Computing... ${i + 1}/${total}`;
    statusEl.style.display = 'block';

    const movesStr = soCube.moveSequence;
    debugLog(`Cube ${i}: solving (${movesStr.split(' ').length} moves)`);

    // Yield between solver calls so browser can paint status
    await new Promise(r => setTimeout(r, 10));

    const t0 = performance.now();
    try {
      let solution;
      if (useWorker) {
        debugLog(`Cube ${i}: sending moves to worker...`);
        const result = await solveInWorker({ moves: movesStr });
        debugLog(`Cube ${i}: worker responded, type=${result.type}`);
        if (result.type === 'error') throw new Error(result.error);
        solution = result.solution;
      } else {
        debugLog(`Cube ${i}: main thread solve (moves)...`);
        await new Promise(r => setTimeout(r, 50));
        const cube = new Cube();
        cube.move(movesStr);
        solution = cube.solve();
      }

      const elapsed = (performance.now() - t0).toFixed(0);
      const moves = parseSolution(solution || '');
      debugLog(`Cube ${i}: ${elapsed}ms, ${moves.length} moves`);
      allSolutions.push(moves);
    } catch (e) {
      const elapsed = (performance.now() - t0).toFixed(0);
      debugLog(`Cube ${i}: ERROR ${elapsed}ms: ${e.message} [${faceletStr}]`);
      allSolutions.push([]);
    }
  }

  statusEl.style.display = 'none';
  debugLog('--- ALL CUBES SOLVED, starting animation ---');

  const speed = getShowOffSpeed();
  const maxLen = Math.max(0, ...allSolutions.map(s => s.length));
  const moveCounts = allSolutions.map(s => s.length);
  debugLog(`Animation: ${maxLen} steps, speed=${speed}ms, moves=[${moveCounts.join(',')}]`);

  try {
    for (let i = 0; i < maxLen; i++) {
      // Log first 3 steps, every 5th step, and last step
      if (i < 3 || i % 5 === 0 || i === maxLen - 1) {
        const movesThisStep = [];
        for (let c = 0; c < showOffCubes.length; c++) {
          if (i < allSolutions[c].length) {
            movesThisStep.push(`c${c}:${allSolutions[c][i].face}${allSolutions[c][i].clockwise ? '' : "'"}`);
          }
        }
        debugLog(`Anim step ${i+1}/${maxLen}: ${movesThisStep.join(' ')}`);
      }

      const promises = [];
      for (let c = 0; c < showOffCubes.length; c++) {
        if (i < allSolutions[c].length) {
          const move = allSolutions[c][i];
          promises.push(showOffCubes[c].doMove(move.face, move.clockwise, speed));
        }
      }

      // Race the animation against a timeout guard (10 seconds)
      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error(`Step ${i+1} timed out after 10s`)), 10000)
      );
      await Promise.race([Promise.all(promises), timeout]);

      // Yield to the browser between steps so it can render and stay responsive
      await new Promise(r => setTimeout(r, 0));
    }
    debugLog('--- ANIMATION COMPLETE ---');
  } catch (e) {
    debugLog(`ANIMATION ERROR at step: ${e.message}`);
  }

  debugLog('Firing confetti');
  confettiSystem.fireFromAllCubes();
  debugLog('--- showOffSolve END ---');
  setShowOffBusy(false);
}

// ─── SHOW OFF: CONTINUOUS PLAY (Per-Cube Pipeline) ───────────

function startCubeScramble(cube) {
  cube.reset();
  const scramble = generateScramble(20);
  cube.pipeline = { phase: 'scrambling', moves: scramble, moveIndex: 0 };
}

function handleCubeTransition(cube, cubeIndex) {
  const p = cube.pipeline;

  if (p.phase === 'scrambling') {
    // Finished scrambling → request solve from worker
    p.phase = 'waiting_solve';
    const movesStr = cube.moveSequence;
    debugLog(`Cube ${cubeIndex}: scramble done → waiting_solve (${movesStr.split(' ').length} moves)`);

    const useWorker = solverWorkerReady;
    if (useWorker) {
      solveInWorker({ moves: movesStr }).then(result => {
        if (!showOffMode) return;

        let solution;
        if (result.type === 'error') {
          debugLog(`Cube ${cubeIndex}: worker error, trying main thread`);
          try {
            const c = new Cube();
            c.move(movesStr);
            solution = c.solve();
          } catch (e) {
            debugLog(`Cube ${cubeIndex}: main thread solve also failed: ${e.message}`);
            solution = '';
          }
        } else {
          solution = result.solution;
        }

        const moves = parseSolution(solution || '');
        debugLog(`Cube ${cubeIndex}: solve ready, ${moves.length} moves`);
        cube.pipeline = { phase: 'solving', moves, moveIndex: 0 };
      });
    } else if (solverReady) {
      try {
        const c = new Cube();
        c.move(movesStr);
        const solution = c.solve();
        const moves = parseSolution(solution || '');
        debugLog(`Cube ${cubeIndex}: main thread solve, ${moves.length} moves`);
        cube.pipeline = { phase: 'solving', moves, moveIndex: 0 };
      } catch (e) {
        debugLog(`Cube ${cubeIndex}: main thread solve failed: ${e.message}`);
        cube.pipeline = { phase: 'idle', moves: [], moveIndex: 0 };
      }
    } else {
      debugLog(`Cube ${cubeIndex}: no solver available, going idle`);
      cube.pipeline = { phase: 'idle', moves: [], moveIndex: 0 };
    }
  }
  else if (p.phase === 'solving') {
    debugLog(`Cube ${cubeIndex}: SOLVED! confetti`);
    confettiSystem.spawnFromCube(cube);

    if (continuousMode) {
      startCubeScramble(cube);
    } else {
      cube.pipeline = { phase: 'idle', moves: [], moveIndex: 0 };
    }
  }
}

function anyCubeActive() {
  return showOffCubes.some(c => c.pipeline.phase !== 'idle');
}

async function continuousLoop() {
  continuousRunning = true;
  document.getElementById('so-scramble').disabled = true;
  document.getElementById('so-solve').disabled = true;

  const speed = getShowOffSpeed();

  // Initialize: all cubes start scrambling
  for (let i = 0; i < showOffCubes.length; i++) {
    startCubeScramble(showOffCubes[i]);
    debugLog(`Cube ${i}: starting scramble`);
  }

  // Beat loop — one move per beat for ALL cubes
  while (showOffMode && (continuousMode || anyCubeActive())) {
    const promises = [];

    for (const cube of showOffCubes) {
      const p = cube.pipeline;

      // Skip idle or waiting cubes
      if (p.phase === 'idle' || p.phase === 'waiting_solve') continue;

      // Execute next move if available
      if (p.moveIndex < p.moves.length) {
        const move = p.moves[p.moveIndex];
        promises.push(cube.doMove(move.face, move.clockwise, speed));
        p.moveIndex++;
      }
    }

    // Wait for this beat's animations (or just wait one beat if nothing to do)
    if (promises.length > 0) {
      await Promise.all(promises);
    } else {
      await new Promise(r => setTimeout(r, speed));
    }
    await new Promise(r => setTimeout(r, 0)); // yield

    // Handle transitions AFTER the beat
    for (let i = 0; i < showOffCubes.length; i++) {
      const cube = showOffCubes[i];
      const p = cube.pipeline;

      if ((p.phase === 'scrambling' || p.phase === 'solving')
          && p.moveIndex >= p.moves.length) {
        handleCubeTransition(cube, i);
      }
    }
  }

  continuousRunning = false;
  if (showOffMode) {
    document.getElementById('so-scramble').disabled = false;
    document.getElementById('so-solve').disabled = false;
  }
}

document.getElementById('so-continuous').addEventListener('change', (e) => {
  continuousMode = e.target.checked;
  if (continuousMode && !continuousRunning && showOffMode) {
    continuousLoop();
  }
});

// Wire buttons
document.getElementById('so-scramble').addEventListener('click', showOffScramble);
document.getElementById('so-solve').addEventListener('click', showOffSolve);

// Wire showoff buttons
document.getElementById('btn-showoff').addEventListener('click', enterShowOffMode);
document.getElementById('so-exit').addEventListener('click', exitShowOffMode);

// Wire crawler buttons
document.getElementById('btn-crawler').addEventListener('click', enterCrawlerMode);
document.getElementById('cr-demo').addEventListener('click', runCrawlerDemo);
document.getElementById('cr-scramble').addEventListener('click', runCrawlerScramble);
document.getElementById('cr-solve').addEventListener('click', runCrawlerSolve);
document.getElementById('cr-reset').addEventListener('click', resetCrawler);
document.getElementById('cr-exit').addEventListener('click', exitCrawlerMode);
document.getElementById('cr-step-fwd').addEventListener('click', crawlerStepForward);
document.getElementById('cr-step-back').addEventListener('click', crawlerStepBack);

// Wire crawler grid size buttons
document.querySelectorAll('[data-crawl-grid]').forEach(btn => {
  btn.addEventListener('click', () => {
    setCrawlerGridSize(parseInt(btn.dataset.crawlGrid));
  });
});

// Speed change mid-solve: switching from Step to a speed auto-continues
document.getElementById('cr-speed').addEventListener('change', () => {
  const val = document.getElementById('cr-speed').value;
  if (crawlerStepSolving && val !== 'step') {
    // Switch from step mode to auto-play with remaining moves
    const remaining = crawlerSolution.moves.slice(crawlerSolution.index);
    exitCrawlerStepMode();
    if (remaining.length > 0) {
      runCrawlerSolveAuto(remaining, 0);
    }
  }
});

// ─── WINDOW RESIZE ───────────────────────────────────────────

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ─── RENDER LOOP ─────────────────────────────────────────────

let lastTickTime = 0;

function tick(now) {
  requestAnimationFrame(tick);
  const dt = lastTickTime ? (now - lastTickTime) / 1000 : 0.016;
  lastTickTime = now;

  orbitControls.update();

  // Drive all show-off cube animations from this single loop
  if (showOffMode) {
    for (const cube of showOffCubes) {
      cube.updateAnimation(now);
    }
  } else if (crawlerMode) {
    if (crawlerCube) crawlerCube.updateAnimation(now);
  } else {
    updateFaceLabels();
    updateFaceButtonLabels();
  }

  if (confettiSystem.active) confettiSystem.update(dt);
  renderer.render(scene, camera);
}

tick();

// Hide loading screen
setTimeout(() => {
  document.getElementById('loading').classList.add('hidden');
}, 500);

// ─── INITIALIZE SOLVER ──────────────────────────────────────

const btnSolveEl = document.getElementById('btn-solve');
btnSolveEl.textContent = 'Solve (loading...)';
btnSolveEl.disabled = true;

// Delay main-thread solver init to avoid blocking during show-off mode.
// Use requestIdleCallback if available, otherwise a long timeout.
function initMainSolver() {
  debugLog('Main solver: initSolver starting...');
  const t0 = performance.now();
  try {
    Cube.initSolver();
    const elapsed = (performance.now() - t0).toFixed(0);
    solverReady = true;
    btnSolveEl.textContent = 'Solve';
    btnSolveEl.disabled = false;
    debugLog(`Main solver: ready in ${elapsed}ms`);
  } catch (err) {
    const elapsed = (performance.now() - t0).toFixed(0);
    debugLog(`Main solver: FAILED in ${elapsed}ms: ${err.message}`);
    console.error('Solver init failed:', err);
    btnSolveEl.textContent = 'Solve (error)';
  }
}
// Use fixed timeout — requestIdleCallback was firing DURING solver await gaps
// and blocking the main thread for 4-5 seconds mid-solve.
setTimeout(initMainSolver, 1000);

// ─── SOLVER WEB WORKER (for show-off mode) ──────────────────
// Runs Kociemba solver in a background thread so the main thread
// stays responsive during multi-cube solves.

let solverWorker = null;
let solverWorkerReady = false;
const solverWorkerCallbacks = {};
let solverWorkerNextId = 0;

function initSolverWorker() {
  try {
    // cubejs has 2 files: lib/cube.js (core) + lib/solve.js (solver).
    // Do NOT provide a module shim — cube.js needs to fall through to
    // the browser path (this.Cube = Cube) so solve.js can find it.
    const code = [
      "importScripts(",
      "  'https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/cube.js',",
      "  'https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/solve.js'",
      ");",
      "postMessage({ type: 'log', msg: 'Worker: Cube.initSolver=' + typeof Cube.initSolver + ', Cube.move=' + typeof Cube.prototype.move });",
      "Cube.initSolver();",
      "postMessage({ type: 'log', msg: 'Worker: initSolver complete' });",
      "postMessage({ type: 'ready' });",
      "onmessage = function(e) {",
      "  try {",
      "    var c;",
      "    if (e.data.moves !== undefined) {",
      "      c = new Cube();",
      "      if (e.data.moves) c.move(e.data.moves);",
      "      postMessage({ type: 'log', msg: 'Worker: built cube from moves, facelet=' + c.asString() });",
      "    } else {",
      "      c = Cube.fromString(e.data.facelet);",
      "      postMessage({ type: 'log', msg: 'Worker: built cube from facelet' });",
      "    }",
      "    var s = c.solve();",
      "    postMessage({ type: 'result', id: e.data.id, solution: s });",
      "  } catch (err) {",
      "    postMessage({ type: 'error', id: e.data.id, error: String(err) });",
      "  }",
      "};"
    ].join('\n');

    const blob = new Blob([code], { type: 'text/javascript' });
    solverWorker = new Worker(URL.createObjectURL(blob));

    solverWorker.onmessage = function(e) {
      if (e.data.type === 'log') {
        debugLog(e.data.msg);
      } else if (e.data.type === 'ready') {
        solverWorkerReady = true;
        debugLog('Solver worker: ready');
      } else {
        const cb = solverWorkerCallbacks[e.data.id];
        if (cb) {
          delete solverWorkerCallbacks[e.data.id];
          cb(e.data);
        }
      }
    };

    solverWorker.onerror = function(e) {
      debugLog('Solver worker error: ' + (e.message || e));
    };

    debugLog('Solver worker: initializing...');
  } catch (e) {
    debugLog('Solver worker: failed to create: ' + e.message);
  }
}

// Send a solve request to the worker.
// opts: { facelet: '...' } or { moves: 'R U F ...' }
function solveInWorker(opts, timeoutMs = 8000) {
  return new Promise((resolve) => {
    const id = ++solverWorkerNextId;
    const timer = setTimeout(() => {
      delete solverWorkerCallbacks[id];
      debugLog(`Worker solve ${id}: TIMED OUT after ${timeoutMs}ms`);
      resolve({ type: 'error', error: 'Solve timed out' });
    }, timeoutMs);
    solverWorkerCallbacks[id] = (result) => {
      clearTimeout(timer);
      resolve(result);
    };
    solverWorker.postMessage({ id, ...opts });
  });
}

// Start worker initialization immediately
initSolverWorker();

</script>
</body>
</html>
